{
    "docs": [
        {
            "location": "/", 
            "text": "Introduction\n\n\nWhat is BackBee ?\n\n\nBackBee is an open source Content Management System (CMS) with one major advantage. BackBee uses On-page Editing Technology (OET) which means you can easily create and manage websites as they appear with no prior technical knowledge.\n\n\nWhat is an Open-page Editing Site?\n\n\nOn-page Editing Technology (OET) is the natural evolution of your usual Content Management System functionalities. On-page Editing Technology is a tool that allows you to enter, edit and manage your website directly as it appears to your users: The back office and front office are merged.\n\n\nWhat's this means?\n\n\nIn most content management systems, you have to shuttle between the back office \u2013 a functional interface \u2013 and a \u201cpreview\u201d mode. Only then can you\u00a0see how the page will be seen by your users.\n\n\nBackBee\u2019s On-Page Editing Technology lets you directly do all your inputting and editing on the page that appears to your users. Therefore you get an immediate and exact idea of what the final page will look like eliminating all unnecessary maneuvers.\n\n\nWhat\u2019s so interesting about this?\n\n\nIt's easier and more flexible than your usual CMS. With BackBee's On-page Editing Technology, you can work directly on your HTML page, the page that's visible to your users. You can drag and drop page elements and move them around as you wish, adding, deleting or changing text, photos or other page elements by simply clicking on the area in question.\n\n\nThe majority of the editorial functions require no back office. BackBee is the first CMS to use On-Page editing Technology merging back office and front office.\n\n\nKey concepts\n\n\n\n\nIt\u2019s unimaginably easy to use.\n\n\nResponsive design is native to the app.\n\n\nIt\u2019s super flexible in terms of graphic design, workflow, SEO and user access.\n\n\nIts secure, in several senses: it saves changes so editorial security is guaranteed; it's easy to configure user access and rights; and the BackBee core is very secure, so developers can make contributions fearlessly.\n\n\nIt\u2019s open source, which means it\u2019s constantly being tested and improved.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#introduction", 
            "text": "", 
            "title": "Introduction"
        }, 
        {
            "location": "/#what-is-backbee", 
            "text": "BackBee is an open source Content Management System (CMS) with one major advantage. BackBee uses On-page Editing Technology (OET) which means you can easily create and manage websites as they appear with no prior technical knowledge.  What is an Open-page Editing Site?  On-page Editing Technology (OET) is the natural evolution of your usual Content Management System functionalities. On-page Editing Technology is a tool that allows you to enter, edit and manage your website directly as it appears to your users: The back office and front office are merged.  What's this means?  In most content management systems, you have to shuttle between the back office \u2013 a functional interface \u2013 and a \u201cpreview\u201d mode. Only then can you\u00a0see how the page will be seen by your users.  BackBee\u2019s On-Page Editing Technology lets you directly do all your inputting and editing on the page that appears to your users. Therefore you get an immediate and exact idea of what the final page will look like eliminating all unnecessary maneuvers.  What\u2019s so interesting about this?  It's easier and more flexible than your usual CMS. With BackBee's On-page Editing Technology, you can work directly on your HTML page, the page that's visible to your users. You can drag and drop page elements and move them around as you wish, adding, deleting or changing text, photos or other page elements by simply clicking on the area in question.  The majority of the editorial functions require no back office. BackBee is the first CMS to use On-Page editing Technology merging back office and front office.", 
            "title": "What is BackBee ?"
        }, 
        {
            "location": "/#key-concepts", 
            "text": "It\u2019s unimaginably easy to use.  Responsive design is native to the app.  It\u2019s super flexible in terms of graphic design, workflow, SEO and user access.  Its secure, in several senses: it saves changes so editorial security is guaranteed; it's easy to configure user access and rights; and the BackBee core is very secure, so developers can make contributions fearlessly.  It\u2019s open source, which means it\u2019s constantly being tested and improved.", 
            "title": "Key concepts"
        }, 
        {
            "location": "/developper-documentation/requirements/", 
            "text": "Developper documentation\n\n\nRequirements for running BackBee CMS\n\n\nTo run BackBee CMS, your system needs to adhere to a list of requirements.\n\n\nBelow is the list of required and optional requirements.\n\n\nRequired\n\n\nBecause BackBee CMS is built on top of Symfony components, theses requirements are required.\n\n\n\n\nJSON\n needs to be enabled\n\n\nctype\n needs to be enabled\n\n\nmbstring\n needs to be enabled\n\n\nYour php configuration needs to have the date.timezone setting completed\n\n\n\n\nMore, PHP needs to be a minimum version of \nPHP 5.4.0\n.\n\n\nOptional\n\n\n\n\nYou (may) need to have the PHP-XML module installed\n\n\nYou (may) need to have at least version 2.6.21 of libxml\n\n\nYou (may) need to have PHP tokenizer module enabled\n\n\nYou (may) need to have iconv module enabled\n\n\nYou (may) need to have POSIX enabled (only on *nix)\n\n\nYou (may) need to have Intl installed with ICU 4+\n\n\nYou (may) need to have APC 3.0.17+ installed (or another opcode cache needs to be installed)\n\n\nphp configuration recommended settings:\n\n\n\n\nshort_open_tag = Off\n\nmagic_quotes_gpc = Off\n\nregister_globals = Off\n\nsession.auto_start = Off\n\n\n\n\nDoctrine2 (Database management)\n\n\nBecause we depend on Doctrine 2, you will need to have PDO installed. Additionally, you need to have the PDO driver installed for the database server you want to use.\nAlso, you need \nphp5-sqlite\n extension to be installed and enabled during the installation process.", 
            "title": "Requirements"
        }, 
        {
            "location": "/developper-documentation/requirements/#developper-documentation", 
            "text": "", 
            "title": "Developper documentation"
        }, 
        {
            "location": "/developper-documentation/requirements/#requirements-for-running-backbee-cms", 
            "text": "To run BackBee CMS, your system needs to adhere to a list of requirements.  Below is the list of required and optional requirements.  Required  Because BackBee CMS is built on top of Symfony components, theses requirements are required.   JSON  needs to be enabled  ctype  needs to be enabled  mbstring  needs to be enabled  Your php configuration needs to have the date.timezone setting completed   More, PHP needs to be a minimum version of  PHP 5.4.0 .  Optional   You (may) need to have the PHP-XML module installed  You (may) need to have at least version 2.6.21 of libxml  You (may) need to have PHP tokenizer module enabled  You (may) need to have iconv module enabled  You (may) need to have POSIX enabled (only on *nix)  You (may) need to have Intl installed with ICU 4+  You (may) need to have APC 3.0.17+ installed (or another opcode cache needs to be installed)  php configuration recommended settings:   short_open_tag = Off\n\nmagic_quotes_gpc = Off\n\nregister_globals = Off\n\nsession.auto_start = Off  Doctrine2 (Database management)  Because we depend on Doctrine 2, you will need to have PDO installed. Additionally, you need to have the PDO driver installed for the database server you want to use.\nAlso, you need  php5-sqlite  extension to be installed and enabled during the installation process.", 
            "title": "Requirements for running BackBee CMS"
        }, 
        {
            "location": "/developper-documentation/installation/", 
            "text": "Developper documentation\n\n\nInstallation\n\n\nInstallation of BackBee in developper mode assume assume you have basic knowledge of PHP5, Apache or Nginx and MySQL.\n\n\nThird party Software\n\n\nFirst of all, you need to check that your computer has a friendly working environment for web development. At a minimum, you need a web server (Apache, for instance), a database engine (MySQL, PostgreSQL, SQLite, or any PDO-compatible database engine), and \nPHP 5.4\n or later.\n\n\nAt least, you need to install \ngit\n and \nComposer\n, the dependency manager for PHP.\n\n\nFollow this link to install it if your are on \nLinux/Unix based OS\n (like ubuntu or Mac OS X), Composer is also available on \nWindows system\n.\n\n\nIn a command line interface, check if \ncomposer\n is correctly installed:\n\n\n\n\nAlso, check your PHP version which should be 5.4 or greater.\n\n\n\n\nEventually, you need to set up a domain name in your operating system.\nOn Unix/Linux based OS, you can add it into \n/etc/hosts\n file, we will choose \nblogbee.dev\n:\n\n\n127.0.0.1   blogbee.dev\n\n\n\nOk ! We can now launch the installation process.\n\n\nWeb Installer\n\n\nOpen a command line interface and get BackBee:\n\n\n$ composer create-project \"backbee/backbee-standard\" /path/to/your/folder \"1.0\" -n\n\n\n\nThen on the \npublic\n directory, launch the builtin server of PHP:\n\n\n$ cd /path/to/your/folder/public \n php -S blogbee.dev:8000\n\n\n\nAnd you should see the first installation step of BackBee (access \nhttp://localhost:8000/install.php\n) in a web browser:\n\n\n\n\nYou need to create \ncache\n and \nlog\n folders with the correct rights, then you can refresh the page and access to the \nsecond step\n of the installer.\n\n\n\n\nIf required, check the \nrepository/Config\n folder rights and then proceed with the \nthird\n step.\n\n\nYou need to set your database settings. If you use a different database engine than MySQL or MariaDB, set the correct driver else you have nothing to change, only fill the fields \ndatabase name\n, \nusername\n and \npassword\n.\n\n\n\n\nYou also need to define your super admin user, fill the credentials then save and continue to the \nfourth\n step.\n\n\n\n\nBackBee Installer creates and populates the database, fill the last information to complete the installation process: the \nsite_name\n and the \ndomain\n.\n\n\n\n\nYou are done: BackBee gives you the \nApache\n or \nNginx\n configuration you have to set to be able to use BackBee on the chosen domain.\n\n\n\n\n\n\nWhen you have set your web server, access the site by going to \nhttp://blogbee.dev\n.\n\n\nIf everything is correctly installed, you should see the BackBee welcome message:\n\n\n\n\n\n\nIf you can't see BackBee welcome message, check both \ncache\n and \nlog\n folders have the correct rights.\n\n\n\n\nYou can even connect to the \"Edition mode\", press  \nCTRL + ALT + B\n to show the login dialog. Note that we created a super admin user for you with login (=admin) and password (=admin).", 
            "title": "Installation"
        }, 
        {
            "location": "/developper-documentation/installation/#developper-documentation", 
            "text": "", 
            "title": "Developper documentation"
        }, 
        {
            "location": "/developper-documentation/installation/#installation", 
            "text": "Installation of BackBee in developper mode assume assume you have basic knowledge of PHP5, Apache or Nginx and MySQL.  Third party Software  First of all, you need to check that your computer has a friendly working environment for web development. At a minimum, you need a web server (Apache, for instance), a database engine (MySQL, PostgreSQL, SQLite, or any PDO-compatible database engine), and  PHP 5.4  or later.  At least, you need to install  git  and  Composer , the dependency manager for PHP.  Follow this link to install it if your are on  Linux/Unix based OS  (like ubuntu or Mac OS X), Composer is also available on  Windows system .  In a command line interface, check if  composer  is correctly installed:   Also, check your PHP version which should be 5.4 or greater.   Eventually, you need to set up a domain name in your operating system.\nOn Unix/Linux based OS, you can add it into  /etc/hosts  file, we will choose  blogbee.dev :  127.0.0.1   blogbee.dev  Ok ! We can now launch the installation process.  Web Installer  Open a command line interface and get BackBee:  $ composer create-project \"backbee/backbee-standard\" /path/to/your/folder \"1.0\" -n  Then on the  public  directory, launch the builtin server of PHP:  $ cd /path/to/your/folder/public   php -S blogbee.dev:8000  And you should see the first installation step of BackBee (access  http://localhost:8000/install.php ) in a web browser:   You need to create  cache  and  log  folders with the correct rights, then you can refresh the page and access to the  second step  of the installer.   If required, check the  repository/Config  folder rights and then proceed with the  third  step.  You need to set your database settings. If you use a different database engine than MySQL or MariaDB, set the correct driver else you have nothing to change, only fill the fields  database name ,  username  and  password .   You also need to define your super admin user, fill the credentials then save and continue to the  fourth  step.   BackBee Installer creates and populates the database, fill the last information to complete the installation process: the  site_name  and the  domain .   You are done: BackBee gives you the  Apache  or  Nginx  configuration you have to set to be able to use BackBee on the chosen domain.    When you have set your web server, access the site by going to  http://blogbee.dev .  If everything is correctly installed, you should see the BackBee welcome message:    If you can't see BackBee welcome message, check both  cache  and  log  folders have the correct rights.   You can even connect to the \"Edition mode\", press   CTRL + ALT + B  to show the login dialog. Note that we created a super admin user for you with login (=admin) and password (=admin).", 
            "title": "Installation"
        }, 
        {
            "location": "/developper-documentation/architecture/", 
            "text": "Developper documentation\n\n\nArchitecture\n\n\nBackBee CMS relies on many Symfony components and on Doctrine 2.\n\n\nThere is the list of components currently used by BackBee CMS:\n\n\n\n\nConfig   \n\n\nConsole   \n\n\nDebug   \n\n\nDependencyInjection   \n\n\nEventDispatcher\n\n\nExpression Language\n\n\nFilesystem\n\n\nHttpFoundation\n\n\nHttpKernel\n\n\nRouting\n\n\nSecurity ACL\n\n\nSecurity Core\n\n\nSecurity HTTP\n\n\nSerializer\n\n\nTranslation\n\n\nValidator\n\n\nYaml\n\n\n(Twig)\n\n\n\n\nBackBee CMS depends on a PHP application (the BackBee \"Core\") which provide a REST API to manage all the contents,\nthe users, the media and the security and to a REST Javascript client which provide to the final users a toolbar\nto ease the management of the contents.\n\n\nTo understand how BackBee CMS is built, take a look on this schema:", 
            "title": "Architecture"
        }, 
        {
            "location": "/developper-documentation/architecture/#developper-documentation", 
            "text": "", 
            "title": "Developper documentation"
        }, 
        {
            "location": "/developper-documentation/architecture/#architecture", 
            "text": "BackBee CMS relies on many Symfony components and on Doctrine 2.  There is the list of components currently used by BackBee CMS:   Config     Console     Debug     DependencyInjection     EventDispatcher  Expression Language  Filesystem  HttpFoundation  HttpKernel  Routing  Security ACL  Security Core  Security HTTP  Serializer  Translation  Validator  Yaml  (Twig)   BackBee CMS depends on a PHP application (the BackBee \"Core\") which provide a REST API to manage all the contents,\nthe users, the media and the security and to a REST Javascript client which provide to the final users a toolbar\nto ease the management of the contents.  To understand how BackBee CMS is built, take a look on this schema:", 
            "title": "Architecture"
        }, 
        {
            "location": "/developper-documentation/configuration/", 
            "text": "Developper documentation\n\n\nConfiguration\n\n\nBackBee CMS is powerful but highly configurable.\nIn this section, all the available configurations are broken down by the key (e.g. doctrine) that defines each possible section of your application configuration.\n\n\nBootstrap configuration (bootstrap.yml)\n\n\nThis configuration file have only two responsabilities:\n\n\n\n\ndebug\n: set the developper mode: if \ntrue\n, the container is generated at each request.\n\n\ncontainer\n: set the container configuration which have 2 parameters\n\n\ndump_directory\n: set the location of the generated container.\n\n\nautogenerate\n: if true, the container is generated at each request.\n\n\n\n\n\n\n\n\nThe \nautogenerate\n option is useful when you want to force the generation of the container in \"production\": don't forget this option have a performance cost.\n\n\nBundles configuration (bundles.yml)\n\n\nTo activate a bundle, you need to register it in this file:\n\n\n# /repository/Config/bundles.yml\ndemo: BackBee\\Bundle\\DemoBundle\\Demo\ntoolbar: BackBee\\Bundle\\ToolbarBundle\\Toolbar\n\n\n\n\n\nDatabase configuration (doctrine.yml)\n\n\nWe provide a demo sample configuration, you can see all available parameters into the related \nDoctrine configuration of Symfony\n:\n\n\n# /repository/Config/doctrine.yml\ndbal:\n    driver: pdo_mysql # [mysql|pgsql|sqlite]\n    host: localhost\n    port: 3306\n    dbname: backbee\n    user: root\n    password: password\n    charset: utf8\n    collation: utf8_general_ci\n    defaultTableOptions: { collate: utf8_general_ci, engine: InnoDB, charset: utf8 }\norm:\n    auto_mapping: true\n    metadata_cache_driver: apc\n    query_cache_driver:\n        type: service\n        id: my_doctrine_common_cache_service # must be a service or a FQCN\n    result_cache_driver:\n        type: memcache\n        host: localhost\n        port: 11211\n        instance_class: Memcache\n\n\n\n\n\nSEO Configuration (metadata.yml)\n\n\nThis is where you set the HTML meta headers you want to configure for each page of BackBee:\n\n\n# /repository/Config/metadata.yml\nkeywords:\n    name: 'keywords'\n    content:\n        default: 'cms, content manager'\ndescription:\n    name: 'description'\n    content:\n        default: \nbackbee demo website\n\n    lang: 'en'\nrobots:\n    name: 'robots'\n    content:\n        default: ''\n        select: ['', 'noindex', 'nofollow', 'noindex, nofollow']\n\n\n\n\n\nThis configuration have a real impact in the toolbar, see the generated SEO form in Page context mode:\n\n\n\n\nSecurity Configuration (security.yml)\n\n\nYou can configure firewalls and suoders inside this file, a sudoer is a super administrator:\n\n\n# /repository/Config/security.yml\nfirewalls:\n    firewall_name: { pattern: ^/, anonymous: null }\nsudoers:\n    username: userId", 
            "title": "Configuration"
        }, 
        {
            "location": "/developper-documentation/configuration/#developper-documentation", 
            "text": "", 
            "title": "Developper documentation"
        }, 
        {
            "location": "/developper-documentation/configuration/#configuration", 
            "text": "BackBee CMS is powerful but highly configurable.\nIn this section, all the available configurations are broken down by the key (e.g. doctrine) that defines each possible section of your application configuration.  Bootstrap configuration (bootstrap.yml)  This configuration file have only two responsabilities:   debug : set the developper mode: if  true , the container is generated at each request.  container : set the container configuration which have 2 parameters  dump_directory : set the location of the generated container.  autogenerate : if true, the container is generated at each request.     The  autogenerate  option is useful when you want to force the generation of the container in \"production\": don't forget this option have a performance cost.  Bundles configuration (bundles.yml)  To activate a bundle, you need to register it in this file:  # /repository/Config/bundles.yml\ndemo: BackBee\\Bundle\\DemoBundle\\Demo\ntoolbar: BackBee\\Bundle\\ToolbarBundle\\Toolbar  Database configuration (doctrine.yml)  We provide a demo sample configuration, you can see all available parameters into the related  Doctrine configuration of Symfony :  # /repository/Config/doctrine.yml\ndbal:\n    driver: pdo_mysql # [mysql|pgsql|sqlite]\n    host: localhost\n    port: 3306\n    dbname: backbee\n    user: root\n    password: password\n    charset: utf8\n    collation: utf8_general_ci\n    defaultTableOptions: { collate: utf8_general_ci, engine: InnoDB, charset: utf8 }\norm:\n    auto_mapping: true\n    metadata_cache_driver: apc\n    query_cache_driver:\n        type: service\n        id: my_doctrine_common_cache_service # must be a service or a FQCN\n    result_cache_driver:\n        type: memcache\n        host: localhost\n        port: 11211\n        instance_class: Memcache  SEO Configuration (metadata.yml)  This is where you set the HTML meta headers you want to configure for each page of BackBee:  # /repository/Config/metadata.yml\nkeywords:\n    name: 'keywords'\n    content:\n        default: 'cms, content manager'\ndescription:\n    name: 'description'\n    content:\n        default:  backbee demo website \n    lang: 'en'\nrobots:\n    name: 'robots'\n    content:\n        default: ''\n        select: ['', 'noindex', 'nofollow', 'noindex, nofollow']  This configuration have a real impact in the toolbar, see the generated SEO form in Page context mode:   Security Configuration (security.yml)  You can configure firewalls and suoders inside this file, a sudoer is a super administrator:  # /repository/Config/security.yml\nfirewalls:\n    firewall_name: { pattern: ^/, anonymous: null }\nsudoers:\n    username: userId", 
            "title": "Configuration"
        }, 
        {
            "location": "/developper-documentation/cookbooks/create_new_commands/", 
            "text": "CookBooks\n\n\nCreate new commands\n\n\nThe Console page of the Components section covers how to create a console application.\nThis cookbook article covers the creation of a command using BackBee Standard Edition.\n\n\nAutomatically Registering Commands\n\n\nTo make the console commands available automatically with BackBee, create a\n\nCommand\n directory inside your bundle and create a PHP file suffixed with\n\nCommand.php\n for each command that you want to provide. For example, if you\nwant to extend the DemoBundle to welcome you from the command line, create\n\nWelcomeCommand.php\n and add the following to it:\n\n\n// bundle/WelcomeBundle/Command/WelcomeCommand.php\nnamespace WelcomeBundle\\Command;\n\nuse Symfony\\Component\\Console\\Input\\InputInterface;\nuse Symfony\\Component\\Console\\Input\\InputArgument;\nuse Symfony\\Component\\Console\\Input\\InputOption;\nuse Symfony\\Component\\Console\\Output\\OutputInterface;\n\n\nuse BackBee\\Console\\AbstractCommand;\n\nclass WelcomeCommand extends AbstractCommand\n{\n    protected function configure()\n    {\n        $this\n            -\nsetName('demo:welcome')\n            -\nsetDescription('Welcome someone')\n            -\naddArgument(\n                'name',\n                InputArgument::OPTIONAL,\n                'Who do you want to welcome?'\n            )\n            -\naddOption(\n                'yell',\n                null,\n                InputOption::VALUE_NONE,\n                'If set, the message will yell in uppercase letters'\n            )\n            -\nsetHelp(\nEOF\nThe \ninfo\n%command.name%\n/info\n command can welcome someone.\nWith the option ``yell``, the message will be displayed in uppercase letters.\nEOF;\n            )\n        ;\n    }\n\n    protected function execute(InputInterface $input, OutputInterface $output)\n    { \n        $text = 'Welcome '.$input-\ngetArgument('name');\n\n        if ($input-\ngetOption('yell')) {\n            $text = strtoupper($text);\n        }\n\n        $output-\nwriteln($text);\n    }\n}\n\n\n\n\nThis command will now automatically be available to run:\n\n\n    $ ./backbee demo:welcome Charles", 
            "title": "Create new commands"
        }, 
        {
            "location": "/developper-documentation/cookbooks/create_new_commands/#cookbooks", 
            "text": "", 
            "title": "CookBooks"
        }, 
        {
            "location": "/developper-documentation/cookbooks/create_new_commands/#create-new-commands", 
            "text": "The Console page of the Components section covers how to create a console application.\nThis cookbook article covers the creation of a command using BackBee Standard Edition.  Automatically Registering Commands  To make the console commands available automatically with BackBee, create a Command  directory inside your bundle and create a PHP file suffixed with Command.php  for each command that you want to provide. For example, if you\nwant to extend the DemoBundle to welcome you from the command line, create WelcomeCommand.php  and add the following to it:  // bundle/WelcomeBundle/Command/WelcomeCommand.php\nnamespace WelcomeBundle\\Command;\n\nuse Symfony\\Component\\Console\\Input\\InputInterface;\nuse Symfony\\Component\\Console\\Input\\InputArgument;\nuse Symfony\\Component\\Console\\Input\\InputOption;\nuse Symfony\\Component\\Console\\Output\\OutputInterface;\n\n\nuse BackBee\\Console\\AbstractCommand;\n\nclass WelcomeCommand extends AbstractCommand\n{\n    protected function configure()\n    {\n        $this\n            - setName('demo:welcome')\n            - setDescription('Welcome someone')\n            - addArgument(\n                'name',\n                InputArgument::OPTIONAL,\n                'Who do you want to welcome?'\n            )\n            - addOption(\n                'yell',\n                null,\n                InputOption::VALUE_NONE,\n                'If set, the message will yell in uppercase letters'\n            )\n            - setHelp( EOF\nThe  info %command.name% /info  command can welcome someone.\nWith the option ``yell``, the message will be displayed in uppercase letters.\nEOF;\n            )\n        ;\n    }\n\n    protected function execute(InputInterface $input, OutputInterface $output)\n    { \n        $text = 'Welcome '.$input- getArgument('name');\n\n        if ($input- getOption('yell')) {\n            $text = strtoupper($text);\n        }\n\n        $output- writeln($text);\n    }\n}  This command will now automatically be available to run:      $ ./backbee demo:welcome Charles", 
            "title": "Create new commands"
        }, 
        {
            "location": "/developper-documentation/cookbooks/customize_error_pages/", 
            "text": "CookBooks\n\n\nCustomize error pages\n\n\nIn BackBee, thanks to Symfony Debug component all errors are treated as exceptions: pages not found or access unauthorized,\neach error is triggered by throwing an exception in your code.\n\n\nAlso, if your are in \"Developper Mode\" BackBee will catch and display a \nbetter\n exception page with a lot of informations\nto help you discover the issue:\n\n\n\n\nIn production, your visitors will see the nice error page provided by BackBee:\n\n\n\n\nError pages for the production environment can be customized in two ways depending on your needs:\n\n\n\n\nIf you just want to design the contents and styles of the error pages, you can set your own error templates\n\n\nIf you need total control of exception handling to execute your own logic, create your own ExceptionListener on \nkernel.exception\n event.\n\n\n\n\nUse your own default templates\n\n\nWhen the error page loads, an internal ExceptionListener is used to render a Twig template to show the user.\n\n\nThis ExceptionListener uses the HTTP status code, the \ndebug\n parameter and the following logic to determine the template filename:\n\n\nBackBee provide core templates which are located into \nvendor/backbee/BackBee/Resources/layouts/error\n.\nIf the template for the status code doesn't exist, this is the default template which is used instead.\n\n\nIn BackBee Standard edition, theses templates are already overriden in the \nToolbarBundle\n, theses templates are located\ninto \nvendor/backbee/toolbar-bundle/Resources/layouts/error\n folder.\n\n\nIf you want to override theses templates, your application might look like this:\n\n\nrepository/\n    Resources/\n        layouts/\n            error/\n                404.phtml\n                500.twig\n                default.phtml\n\n\n\n\nIn case you need them, the ExceptionController passes some information to the error template via the error variable which act as the original PHP exception so you can access the HTTP status code and exception message.", 
            "title": "Customize error pages"
        }, 
        {
            "location": "/developper-documentation/cookbooks/customize_error_pages/#cookbooks", 
            "text": "", 
            "title": "CookBooks"
        }, 
        {
            "location": "/developper-documentation/cookbooks/customize_error_pages/#customize-error-pages", 
            "text": "In BackBee, thanks to Symfony Debug component all errors are treated as exceptions: pages not found or access unauthorized,\neach error is triggered by throwing an exception in your code.  Also, if your are in \"Developper Mode\" BackBee will catch and display a  better  exception page with a lot of informations\nto help you discover the issue:   In production, your visitors will see the nice error page provided by BackBee:   Error pages for the production environment can be customized in two ways depending on your needs:   If you just want to design the contents and styles of the error pages, you can set your own error templates  If you need total control of exception handling to execute your own logic, create your own ExceptionListener on  kernel.exception  event.   Use your own default templates  When the error page loads, an internal ExceptionListener is used to render a Twig template to show the user.  This ExceptionListener uses the HTTP status code, the  debug  parameter and the following logic to determine the template filename:  BackBee provide core templates which are located into  vendor/backbee/BackBee/Resources/layouts/error .\nIf the template for the status code doesn't exist, this is the default template which is used instead.  In BackBee Standard edition, theses templates are already overriden in the  ToolbarBundle , theses templates are located\ninto  vendor/backbee/toolbar-bundle/Resources/layouts/error  folder.  If you want to override theses templates, your application might look like this:  repository/\n    Resources/\n        layouts/\n            error/\n                404.phtml\n                500.twig\n                default.phtml  In case you need them, the ExceptionController passes some information to the error template via the error variable which act as the original PHP exception so you can access the HTTP status code and exception message.", 
            "title": "Customize error pages"
        }, 
        {
            "location": "/developper-documentation/components/config/", 
            "text": "Components\n\n\nThe Config component\n\n\nThis component is used in BackBee to set parameters from YAML files into the Container.\n\n\nHow the Config component work ?\n\n\nThe BackBee Config Component provide a \nConfig\n object able to:\n\n\n\n\nParse YAML files from a directory;\n\n\nPersist this configuration in file or in database;\n\n\nSet this configuration in \nBackBee Container\n;\n\n\nSave and load configuration from \nBackBee Cache\n;\n\n\n\n\n?php\n\nuse BackBee\\Cache\\AbstractCache;\nuse BackBee\\Config\\Config;\nuse BackBee\\DependencyInjection\\Container;\nuse BackBee\\DependencyInjection\\DispatchTagEventInterface;\nuse BackBee\\DependencyInjection\\Dumper\\DumpableServiceInterface;\n\nclass Config implements DispatchTagEventInterface, DumpableServiceInterface\n{\n    public function __construct(\n        $basedir,\n        AbstractCache $cache = null,\n        Container $container = null,\n        $debug = false,\n        array $yml_to_ignore = []\n    ){/*..*/}\n}\n\n?\n\n\n\n\n\nThis component is not related and not compatible with Symfony Config component.\n\n\nYAML parsing, filtering and extending\n\n\nThe BackBee Config Component can take a valid directory as argument, and merge the configuration according to the data set\nin this YAML files. If you don't know YAML, you can take a look to the \nSymfony YAML format documentation\n.\n\n\nMoreover, BackBee Config component allow you to ignore some files.\n\n\n?php\n\nuse BackBee\\Config\\Config;\n\nclass Foo\n{\n    const DIRECTORY = '/my-valid/path';\n\n    public function returnConfiguration(array $filesToIgnore)\n    {\n        return new Config(self::DIRECTORY, null, null, false, $filesToIgnore);\n    }\n}\n\n?\n\n\n\n\n\nThis way, the ignored files won't be parsed.\n\n\nThanks to the \nBackBee environments\n, you can also extend and improve your default configuration.\nFor instance, let's say you want to add a specific configuration when your are in \"testing\" environment.\n\n\nYou can set the environment this way:\n\n\n?php\n\nuse BackBee\\Config\\Config;\n\nclass Foo\n{\n    const DIRECTORY = '/my-valid/path';\n\n    public function TestingConfiguration()\n    {\n        $config = new Config('/repository/Config', null, null, false, []);\n\n        return $config-\nsetEnvironment('testing');\n\n        /**\n         * Now the object is able to parse YAML files from theses directories:\n         * /repository/Config\n         * /repository/Config/testing\n         * and we are also able to parse specific \nenvironment files\n:\n         * /repository/Config/foo.testing.yml\n         */\n    }\n}\n\n?\n\n\n\n\n\nThis is simple and powerful, you can be very specific on the configuration you want to use.\nConfigurations keys and parameters are merged recursively, starting from base directory to the environnement directory.\nThank to the \"On cascade system\", you can also add a new directory to allow an override of the current configuration.\n\n\n?php\n\nuse BackBee\\Config\\Config;\n\nclass Foo\n{\n    const DIRECTORY = '/my-valid/path';\n\n    public function overrideTestingConfiguration(Config $config, $directory)\n    {\n        return $config-\nextend($directory);\n\n        /**\n         * Now the object is able to parse YAML files from theses directories:\n         * /repository/Config/\n$directory\n\n         * If a key is declared in \n$directory\n configuration files, the configuration is overriden\n         */\n    }\n}\n\n?\n\n\n\n\n\nConfiguration persisting\n\n\nThe BackBee Config Component can persist configurations in file or in database, you can also create your owns \"persistors\"\nthanks to the \nBackBee\\Config\\PersistorInterface\n.\n\n\nFor now, two persistors are provided in BackBee CMS:\n\n\n\n\nthe \nFile\n Persistor allow you to write and override the main configuration file (config.yml)\n\n\nthe \nRegistry\n Persistor is a simple database Key/Value system\n\n\n\n\nIf we take a look to the BackBee CMS configuration:\n\n\nconfig:\n    save_in_registry: true # default value: true\n    persistor: [BackBee\\Config\\Persistor\\File, BackBee\\Config\\Persistor\\Registry]\n\n\n\n\n\n\nsave_in_registry\n is a particular option: if true, this means BackBee will try to look for an overidden configuration\n  stored in Registry.\n\n\npersistor\n is the list of activated persistor, BackBee will loop on each and try to find configuration. If no one\n  provide the requested configuration, an exception will be throw.\n\n\n\n\nConfiguration caching\n\n\nThe BackBee Config Component is fully compatible with BackBee Cache component.\n\n\nWhen you create your Config object, you can pass an instance of \nBackBee\\Cache\\AbstractCache\n as a second argument.\nThis way, in non-debug mode (fourth argument, \nfalse\n by default), the second time you get the information, the configuration\nwill be constructed from cache instead of built again from files or database registry.", 
            "title": "Config"
        }, 
        {
            "location": "/developper-documentation/components/config/#components", 
            "text": "", 
            "title": "Components"
        }, 
        {
            "location": "/developper-documentation/components/config/#the-config-component", 
            "text": "This component is used in BackBee to set parameters from YAML files into the Container.", 
            "title": "The Config component"
        }, 
        {
            "location": "/developper-documentation/components/config/#how-the-config-component-work", 
            "text": "The BackBee Config Component provide a  Config  object able to:   Parse YAML files from a directory;  Persist this configuration in file or in database;  Set this configuration in  BackBee Container ;  Save and load configuration from  BackBee Cache ;   ?php\n\nuse BackBee\\Cache\\AbstractCache;\nuse BackBee\\Config\\Config;\nuse BackBee\\DependencyInjection\\Container;\nuse BackBee\\DependencyInjection\\DispatchTagEventInterface;\nuse BackBee\\DependencyInjection\\Dumper\\DumpableServiceInterface;\n\nclass Config implements DispatchTagEventInterface, DumpableServiceInterface\n{\n    public function __construct(\n        $basedir,\n        AbstractCache $cache = null,\n        Container $container = null,\n        $debug = false,\n        array $yml_to_ignore = []\n    ){/*..*/}\n}\n\n?   This component is not related and not compatible with Symfony Config component.", 
            "title": "How the Config component work ?"
        }, 
        {
            "location": "/developper-documentation/components/config/#yaml-parsing-filtering-and-extending", 
            "text": "The BackBee Config Component can take a valid directory as argument, and merge the configuration according to the data set\nin this YAML files. If you don't know YAML, you can take a look to the  Symfony YAML format documentation .  Moreover, BackBee Config component allow you to ignore some files.  ?php\n\nuse BackBee\\Config\\Config;\n\nclass Foo\n{\n    const DIRECTORY = '/my-valid/path';\n\n    public function returnConfiguration(array $filesToIgnore)\n    {\n        return new Config(self::DIRECTORY, null, null, false, $filesToIgnore);\n    }\n}\n\n?   This way, the ignored files won't be parsed.  Thanks to the  BackBee environments , you can also extend and improve your default configuration.\nFor instance, let's say you want to add a specific configuration when your are in \"testing\" environment.  You can set the environment this way:  ?php\n\nuse BackBee\\Config\\Config;\n\nclass Foo\n{\n    const DIRECTORY = '/my-valid/path';\n\n    public function TestingConfiguration()\n    {\n        $config = new Config('/repository/Config', null, null, false, []);\n\n        return $config- setEnvironment('testing');\n\n        /**\n         * Now the object is able to parse YAML files from theses directories:\n         * /repository/Config\n         * /repository/Config/testing\n         * and we are also able to parse specific  environment files :\n         * /repository/Config/foo.testing.yml\n         */\n    }\n}\n\n?   This is simple and powerful, you can be very specific on the configuration you want to use.\nConfigurations keys and parameters are merged recursively, starting from base directory to the environnement directory.\nThank to the \"On cascade system\", you can also add a new directory to allow an override of the current configuration.  ?php\n\nuse BackBee\\Config\\Config;\n\nclass Foo\n{\n    const DIRECTORY = '/my-valid/path';\n\n    public function overrideTestingConfiguration(Config $config, $directory)\n    {\n        return $config- extend($directory);\n\n        /**\n         * Now the object is able to parse YAML files from theses directories:\n         * /repository/Config/ $directory \n         * If a key is declared in  $directory  configuration files, the configuration is overriden\n         */\n    }\n}\n\n?", 
            "title": "YAML parsing, filtering and extending"
        }, 
        {
            "location": "/developper-documentation/components/config/#configuration-persisting", 
            "text": "The BackBee Config Component can persist configurations in file or in database, you can also create your owns \"persistors\"\nthanks to the  BackBee\\Config\\PersistorInterface .  For now, two persistors are provided in BackBee CMS:   the  File  Persistor allow you to write and override the main configuration file (config.yml)  the  Registry  Persistor is a simple database Key/Value system   If we take a look to the BackBee CMS configuration:  config:\n    save_in_registry: true # default value: true\n    persistor: [BackBee\\Config\\Persistor\\File, BackBee\\Config\\Persistor\\Registry]   save_in_registry  is a particular option: if true, this means BackBee will try to look for an overidden configuration\n  stored in Registry.  persistor  is the list of activated persistor, BackBee will loop on each and try to find configuration. If no one\n  provide the requested configuration, an exception will be throw.", 
            "title": "Configuration persisting"
        }, 
        {
            "location": "/developper-documentation/components/config/#configuration-caching", 
            "text": "The BackBee Config Component is fully compatible with BackBee Cache component.  When you create your Config object, you can pass an instance of  BackBee\\Cache\\AbstractCache  as a second argument.\nThis way, in non-debug mode (fourth argument,  false  by default), the second time you get the information, the configuration\nwill be constructed from cache instead of built again from files or database registry.", 
            "title": "Configuration caching"
        }, 
        {
            "location": "/developper-documentation/components/event_listener/", 
            "text": "Components\n\n\nThe Event Listener component\n\n\nEvents\n are a common and effective way to tie together loosely coupled components in an application.\nAn event is generally used to broadcast a change that has occured during a process. If a \ncomponent\n is\ninterested in a particular event, he can \nlisten\n to it. When this particular event is triggered, a \nmethod\n,\noften called \ncallback\n or \nhandler\n is executed. Events are convenient ways to share\ndata between components.\nIn \nBackBee\n, events are triggered by an \nEventDispatcher\n and an \nEventListener\n is used to listen to them.\n\n\nEvent\n\n\nNamespace: BackBee\\Event\\Event\n\n\nThe Backbee event class extend \nsfEvent\n and allows us to create a generic \nEvent\n object.\nAn generic event object has two properties: \ntarget\n and \nargs\n;\nThe target property represents the target of the event. The \nargs\n is an optional associated map.\nWhen the \nargs\n property is provided, it's sent to the listeners.\nCustom Event can be created by extending the class \nBackBee\\Event\\Event\n.\n\n\n?php\n$myHelloEvent = new Event($target, array(\nmessage\n=\nHello BackBee\n);\n\n\n\n\n\nEvent Listener\n\n\nNamespace: BackBee\\Event\\EventListener\n\n\nTo listen to an event we must use the \naddListener\n method of the \nEventDispatcher\n.\n\naddListener\n takes three parameters. The first one is the name of the event that will be triggered, the second is an array whose first element\nis a class path and the second is a method. The last parameter is the priority of the event. Listener with higher priority will be triggered first.\n\n\n$this-\napplication-\ngetEventDispatcher()-\naddListener(\"loading.event\", array(\"BackBee/Event/Listener/HelloListener\", \"sayHello\"));\n\n\n\nHere we register the listener \nHelloListener\n to be executed when the event \nloading.event\n is occured.\n\n\n    \n?php\n\n        namespace BackBee\\Event\\Listener;\n        use BackBee\\Event\\Event;\n\n        class HelloListener {\n\n            public static sayHello (Event $event) {\n\n                $dispatcher = $event-\ngetDispatcher();\n\n                if ($event-\nhasArguments(\nmessage\n)) {\n                    $message = $event-\nget(\nmessage\n);\n                    if ( null !== $dispatcher-\ngetApplication()) {\n                        $dispatcher-\ngetApplication()-\ngetLogging()-\nnotice($message);\n                    }\n                }\n            }\n        }\n\n    ?\n\n\n\n\n\nNotice that the event object has access to the \napplication\n \nvia\n the \nEventDispacher\n and that the \nsayHello\n is a \nstatic\n method.\n\n\nEvent Dispatcher\n\n\nNamespace: BackBee\\Event\\EventListener\n\n\nEvents are \ndispatched\n or \ntriggered\n by the \nEventDispatcher\n by using the method \ntriggerEvent\n\nThe sample bellow shows how to listen to an event.\n\n\nTo trigger an event, we must use the \nEventDispatcher\n. It provides, among others, a \ndispatch\n method that takes two arguments. A name and an event object.\n\n\n?php\n    $this-\napplication-\ngetEventDispatcher()-\ndispatch(\nloading.event\n, $myHelloEvent);\n\n\n\n\nWhen the \nloading.event\n is dispatched by the \nEventDispatcher\n, all the registered listeners will be executed. In our example,\nthe static \nsayHello\n method of the \nBackbee/Event/Listener/HelloListener\n will be called.\n\n\nEvents from Class Content Component\n\n\nOne of the main purpose of \nBackbee\n is to render contents. As we have seen, a\ncontent is defined in a \n.yml\n file. Content creation and content rendering go\nthrough many phases that \nBackbee\n exposes with events. By instance, an event is triggered\nwhen a content is created, before and after a content has been saved, when the rendering process\nis started, while the content is been rendered, after the renderer process and so on. these events\nallow us the alter in different ways the contents lifecycle or the rendering process itself.\n\n\nClassContent events are similar to custom events. But, as they take place when the main application\nis dealing with a request, a common way to listen to them is to use an \nevent.yml\n config file.\nWill try to local event file in the \nrepository/Config\n folder. Bellow is an example of how to\nuse the file.\n\n\n    article.article.render:\n        listeners:\n            - [BackBee\\Event\\Listener\\ArticleListener, onRender]\n\n    social.facebook.prerender:\n        listeners:\n            - [BackBee\\Event\\Listener\\Socialistener, PrerenderFacebook]\n\n\n\n\nevents.yml\n is a declarative way to add listeners to \nClassContentEvents\n event. Under the hook,\nthis yaml file is parsed and the \nEventDispatcher\n is used to register the listeners.\nIn our example,  \narticle.article.render\n and \nsocial.facebook.prerender\n are events names.\nBy convention \nBackBee\n transforms ClassContent class path to event name. Let's take a look at our events files.\n\n\nAccording to our \nevent.yml\n, the \narticle.article.render\n event will be triggered when\nthe content \nClassContent/Article/Article.yml\n is about the be rendered whereas\nthe 'social.facebook.prerender' will be triggered \nbefore\n the content \nClassContent/Social/Facebook.yml\n\nwas rendered.\n\n*.render\n  and \n*.prerender\n are events triggered by the \nRenderer\n object. Bellow is the list of\nall the Renderer events.\n\n\n\n\n*.prerender\n\n\n*.render\n\n\n*.postrender\n\n\n\n\nprerender\n is triggered \nbefore\n the content is been rendered. \nrender\n when the\n content is about to be rendered and \npostrender\n after the render process. How ever There is no strong difference \nrender\n and \npostrender\n.\n\n\nAs in BackBee all the contents are \nDoctrine\n entities, these doctrine events are also available for all the contents.\n\n\n\n\npreremove\n\n\npostremove\n\n\npostupdate\n\n\npreupdate\n\n\nupdate\n\n\nprepersist\n\n\npostpersist\n\n\npostload\n\n\nonflush\n\n\n\n\nClassContent Listener\n\n\nTo listen to a ClassContentEvent we have to create a \nListener\n class. By default Backbee\nwill looks for Listener in the repository/Config/Listener folder.\n\n\n    \n?php\n        namespace BackBee\\Event\\Listener,\n        use BackBee\\Event\\Event;\n\n        class ArticleListener extends Event {\n\n            public static function onRender(Event $event){\n                /* The renderer object */\n                $renderer = $event-\ngetEventArgs();\n\n                /* The eventDispatcher */\n                $eventDistacher = $event-\ngetDispatcher();\n\n                /* the BackBee application */\n                $application = $eventDistacher-\ngetApplication();\n\n                /* The article classcontent */\n                $content = $renderer-\ngetObject();\n\n                /*Add a new parameter that will be available in the content template*/\n                $renderer-\nassign('myParams', \nmy Param value\n);\n            }\n        }\n    ?\n\n\n\n\n\nEvent inheritance\n\n\nThe last feature we will cover is ClassContent event inheritance. In \nBackBee\n\ncontent can be inherited from one another. The \nEventDispatcher\n respects this inheritance.\nIf a event is triggered for a subContent it will also be triggered for its parent. So \nclass content\n Events bubble up in BackBee.", 
            "title": "Event Listener"
        }, 
        {
            "location": "/developper-documentation/components/event_listener/#components", 
            "text": "", 
            "title": "Components"
        }, 
        {
            "location": "/developper-documentation/components/event_listener/#the-event-listener-component", 
            "text": "Events  are a common and effective way to tie together loosely coupled components in an application.\nAn event is generally used to broadcast a change that has occured during a process. If a  component  is\ninterested in a particular event, he can  listen  to it. When this particular event is triggered, a  method ,\noften called  callback  or  handler  is executed. Events are convenient ways to share\ndata between components.\nIn  BackBee , events are triggered by an  EventDispatcher  and an  EventListener  is used to listen to them.", 
            "title": "The Event Listener component"
        }, 
        {
            "location": "/developper-documentation/components/event_listener/#event", 
            "text": "Namespace: BackBee\\Event\\Event  The Backbee event class extend  sfEvent  and allows us to create a generic  Event  object.\nAn generic event object has two properties:  target  and  args ;\nThe target property represents the target of the event. The  args  is an optional associated map.\nWhen the  args  property is provided, it's sent to the listeners.\nCustom Event can be created by extending the class  BackBee\\Event\\Event .  ?php\n$myHelloEvent = new Event($target, array( message = Hello BackBee );", 
            "title": "Event"
        }, 
        {
            "location": "/developper-documentation/components/event_listener/#event-listener", 
            "text": "Namespace: BackBee\\Event\\EventListener  To listen to an event we must use the  addListener  method of the  EventDispatcher . addListener  takes three parameters. The first one is the name of the event that will be triggered, the second is an array whose first element\nis a class path and the second is a method. The last parameter is the priority of the event. Listener with higher priority will be triggered first.  $this- application- getEventDispatcher()- addListener(\"loading.event\", array(\"BackBee/Event/Listener/HelloListener\", \"sayHello\"));  Here we register the listener  HelloListener  to be executed when the event  loading.event  is occured.       ?php\n\n        namespace BackBee\\Event\\Listener;\n        use BackBee\\Event\\Event;\n\n        class HelloListener {\n\n            public static sayHello (Event $event) {\n\n                $dispatcher = $event- getDispatcher();\n\n                if ($event- hasArguments( message )) {\n                    $message = $event- get( message );\n                    if ( null !== $dispatcher- getApplication()) {\n                        $dispatcher- getApplication()- getLogging()- notice($message);\n                    }\n                }\n            }\n        }\n\n    ?   Notice that the event object has access to the  application   via  the  EventDispacher  and that the  sayHello  is a  static  method.", 
            "title": "Event Listener"
        }, 
        {
            "location": "/developper-documentation/components/event_listener/#event-dispatcher", 
            "text": "Namespace: BackBee\\Event\\EventListener  Events are  dispatched  or  triggered  by the  EventDispatcher  by using the method  triggerEvent \nThe sample bellow shows how to listen to an event.  To trigger an event, we must use the  EventDispatcher . It provides, among others, a  dispatch  method that takes two arguments. A name and an event object.  ?php\n    $this- application- getEventDispatcher()- dispatch( loading.event , $myHelloEvent);  When the  loading.event  is dispatched by the  EventDispatcher , all the registered listeners will be executed. In our example,\nthe static  sayHello  method of the  Backbee/Event/Listener/HelloListener  will be called.", 
            "title": "Event Dispatcher"
        }, 
        {
            "location": "/developper-documentation/components/event_listener/#events-from-class-content-component", 
            "text": "One of the main purpose of  Backbee  is to render contents. As we have seen, a\ncontent is defined in a  .yml  file. Content creation and content rendering go\nthrough many phases that  Backbee  exposes with events. By instance, an event is triggered\nwhen a content is created, before and after a content has been saved, when the rendering process\nis started, while the content is been rendered, after the renderer process and so on. these events\nallow us the alter in different ways the contents lifecycle or the rendering process itself.  ClassContent events are similar to custom events. But, as they take place when the main application\nis dealing with a request, a common way to listen to them is to use an  event.yml  config file.\nWill try to local event file in the  repository/Config  folder. Bellow is an example of how to\nuse the file.      article.article.render:\n        listeners:\n            - [BackBee\\Event\\Listener\\ArticleListener, onRender]\n\n    social.facebook.prerender:\n        listeners:\n            - [BackBee\\Event\\Listener\\Socialistener, PrerenderFacebook]  events.yml  is a declarative way to add listeners to  ClassContentEvents  event. Under the hook,\nthis yaml file is parsed and the  EventDispatcher  is used to register the listeners.\nIn our example,   article.article.render  and  social.facebook.prerender  are events names.\nBy convention  BackBee  transforms ClassContent class path to event name. Let's take a look at our events files.  According to our  event.yml , the  article.article.render  event will be triggered when\nthe content  ClassContent/Article/Article.yml  is about the be rendered whereas\nthe 'social.facebook.prerender' will be triggered  before  the content  ClassContent/Social/Facebook.yml \nwas rendered. *.render   and  *.prerender  are events triggered by the  Renderer  object. Bellow is the list of\nall the Renderer events.   *.prerender  *.render  *.postrender   prerender  is triggered  before  the content is been rendered.  render  when the\n content is about to be rendered and  postrender  after the render process. How ever There is no strong difference  render  and  postrender .  As in BackBee all the contents are  Doctrine  entities, these doctrine events are also available for all the contents.   preremove  postremove  postupdate  preupdate  update  prepersist  postpersist  postload  onflush", 
            "title": "Events from Class Content Component"
        }, 
        {
            "location": "/developper-documentation/components/event_listener/#classcontent-listener", 
            "text": "To listen to a ClassContentEvent we have to create a  Listener  class. By default Backbee\nwill looks for Listener in the repository/Config/Listener folder.       ?php\n        namespace BackBee\\Event\\Listener,\n        use BackBee\\Event\\Event;\n\n        class ArticleListener extends Event {\n\n            public static function onRender(Event $event){\n                /* The renderer object */\n                $renderer = $event- getEventArgs();\n\n                /* The eventDispatcher */\n                $eventDistacher = $event- getDispatcher();\n\n                /* the BackBee application */\n                $application = $eventDistacher- getApplication();\n\n                /* The article classcontent */\n                $content = $renderer- getObject();\n\n                /*Add a new parameter that will be available in the content template*/\n                $renderer- assign('myParams',  my Param value );\n            }\n        }\n    ?", 
            "title": "ClassContent Listener"
        }, 
        {
            "location": "/developper-documentation/components/event_listener/#event-inheritance", 
            "text": "The last feature we will cover is ClassContent event inheritance. In  BackBee \ncontent can be inherited from one another. The  EventDispatcher  respects this inheritance.\nIf a event is triggered for a subContent it will also be triggered for its parent. So  class content  Events bubble up in BackBee.", 
            "title": "Event inheritance"
        }, 
        {
            "location": "/developper-documentation/components/security/", 
            "text": "Components\n\n\nThe Security component\n\n\nBackBee\n Security component is based on the Security Component of \nSymfony\n.\n\n\nIt provides a robust way to secure a web application. Here we will present some of the core concepts of this component : \nfirewall\n, \nFirewallMap\n, \nauthentication\n , \nauthorization\n, \nDecissionAccess\n,  \nVoter\n, \nSecurityContext\n.\n\n\nOverview of security mechanism\n\n\nThe main propose of the security component is to deal with \nauthentication\n and \nauthorization\n.\n\n\nAuthentication is a way to grant access to a ressource. When a user is successfully authentified, authorization is a way to control access to a specific ressource.\n\n\nAuthentication is handled by what is called a \nfirewall\n. A application can have many secured areas, an admin area by instance.\n\n\nA secured area is determined by an \nurl\n. When an url that is part of a secured area is requested, behind the hook some registered callbacks are executed.\n\n\nThe \nFirewall\n archives this by listening to the \nsymfony\n \nkernel.request\n event triggered by the HttpKernel.\nA \nFirewallMap\n  that maps a \nrequest\n with the registered listeners then checks if the current request is under a secured area or is already secured.\n\n\nA \nFirewallMap\n Listener can authenticate a request, throws an \nAuthenticationException\n or do nothing. If one of these listener throws an exception meaning that the request is not authentificated, this exception can either be transformed into an \nAccessDeniedHttpException\n or used to initiate an authentication process by calling the \nFirewall\n entry point.\n\n\nAuthentication\n\n\nA firewall entry point, as it implements the \nauthenticationEntryPointInterface\n, must provided a \nstart\n method which takes two parameters: a request and the exception previously raised.\n\n\nstart\n must returns a \nResponse\n object that can be a page showing a form by instance.\nIf one the FirewallMap Listener can handle the request, it creates a \nToken\n object that holds a reference to the current user, his role and his credentials.\nThe listener then uses an \nauthenticationProviderManager\n object to authenticate the \nToken\n. \nauthenticationProviderManager\n will authenticate the token if provided and return an \nauthenticated\n one if the user credential is valid.\n\n\nOtherwise an \nAuthenticationException\n is raised.\nEach \nToken\n uses a specific type of \nauthenticationProvider\n. An \nauthenticationProvider\n must implements the \nauthenticationProviderInterface\n and provides the two methods :  \nauthentificate\n which takes one paramater that must implements the \nTokenInterface\n and \nsupports\n which is used to check rather or not the given \ntoken\n is supported by the authentication provider .\n\n\nRegistered FirewallMap Listeners must implement the \nListenerInterface\n thus provided an \nhandle\n method that accept an \nGetRequestEvent\n object.\n\n\nAuthorization\n\n\nOnce a user is identified his roles or any other attributes or object of its \ntoken\n can be used to determine rather or not he has access to a resource.\n\n\nDecision manager\n\n\nAn \nAccessControlManager\n is used for making final access decisions based on \nVoter\n.\n\n\nA voter can decide to \nvote\n either for grant or deny access to a ressource. A voter can also abstrain itself.\n\n\nBy default The \nAccessControllerManagers\n make his decision according to one these three strategies:\n\n\n\n\naffirmative\n (Access is granted if any voter votes for granting access)\n\n\nconsensus\n (Access is granted if there are more voters willing to granting access then otherwise\n\n\nunanimous\n (Access is granted if all voters vote for granting access)\n\n\n\n\nUnderstand voters\n\n\nA voter class must implements the \nVoterInterface\n which has 4 methods:\n\n\n\n\nsupportsAttribute($attribute)\n\n\nsupportsClass($class)\n\n\nvote(TokentInterface $token, $object, $attributes)\n\n\n\n\nsupportsAttribute\n is used to check if the voter supports some attributes of the token.\n\nsupportClass\n is user to check it the voter supports a specific class\n\nvote\n handle the vote strategy and must return of those class Constant :\n\n\n\n\nVoterInterface::ACCESS_GRANTED\n\n\nVoterInterface::ACCESS_ABSTAIN\n\n\nVoterInterface::ACCESS_DENIED\n\n\n\n\nBellow is list of Voter used in BackBee\n- AccessVoter\n- BBAclVoter\n- BBRoleVoter\n- SudoVoter\n\n\nBackBee SecurityContext and the ContextInterface\n\n\nAll the process of creating \nFirewall\n, \nFirewallMap\n, \nAuthenticationManager\n, \nAccessDecisionMananger\n and listeners is handled by the \nBackBee\\Security\\SecurityContext\n object.\n\n\nHowever to way of dealing with security Listerners is simplyfied by using a \nContext\n object.\nA security \nContext\n extends the abstract class \nBackBee\\Security\\Context\\BBAuthContext\n and defines the \nloadListeners\n method.\n\n\nLoadListeners\n accepts one parameter which is the security config that can be setted is \nrepository/Config/security.yml\n. A context can be used to instanciate new listener or to register new authentication provider to the \nSecuriryContext\n.\n\n\nBellow we show all the  security contexts provided by BackBee.\n\n\n\n\nAnonymousContext\n\n\nBBAuthContext\n\n\nLogoutContext\n\n\nRestfulContext\n\n\nStatelessContext\n\n\nUsernamePasswordContext\n\n\n\n\nAnonymousContext\n\n\nAnonymouseContext\n is used to identify anonymous user.\n\n\n\n\nauthentication provider\n : \nBackBee\\Security\\Authentication\\Provider\\AnonymousAuthenticationProvider\n\n\nListener\n: \nBackBee\\Security\\Listeners\\AnonymousAuthenticationListener\n\n\nToken\n : \nBackBee\\Security\\Token\\AnonymousToken\n\n\n\n\nBBAuthContext\n\n\nBBAuthContext\n is used to authentify a user by using the BackBee User table.\n\n\n\n\nauthentication provider\n : \nBackBee\\Security\\Authentication\\Provider\\BBAuthenticationProvider\n\n\nListener\n: \nBackBee\\Security\\Listeners\\AnonymousAuthenticationListener\n\n\nToken\n : \nBackBee\\Security\\Token\\BBUserToken\n\n\n\n\nLogoutContext\n\n\nLogoutContext\n handles user logout by removing all setted tokens.\n\n\n\n\nauthentication provider\n : \nnone\n\n\nToken\n : \nnone\n\n\nListener\n: \nBackBee\\Security\\Listeners\\LogoutListener\n\n\n\n\nRestfulContext\n\n\nRestfulContext\n is used to authentify rest user with a plublic key.\n\n\n\n\nauthentication provider\n: \nBackBee\\Security\\Listeners\\PublicKeyAuthenticationProvider\n\n\nListener\n : \nBackBee\\Security\\Listeners\\PublicKeyAuthenticationListener\n\n\nToken\n: \nBackBee\\Security\\Token\\BBUserToken\n\n\n\n\nStatelessContext\n\n\nIn stateless mode authentication is asked for every requests. \nStatelessContext\n handles sessions\ncreation every time stateless mode is disabled.\n\n\n\n\nauthentication provider\n: \nnone\n\n\nListener\n: \nBackBee\\Security\\Listeners\\ContextListener\n\n\nToken\n: \nnone\n\n\n\n\nUsernamePasswordContext\n\n\nUsernamePasswordContext\nis used to authenticate user by using a login form.\n\n\n\n\nauthentication provider\n: \nBackBee\\Security\\Listeners\\Provider\\UserAuthenticationProvider\n\n\nListener\n: \nBackBee\\Security\\Listeners\\UsernamePasswordAuthenticationListener\n\n\nToken\n: \nBackBee\\Security\\Token\\UsernamePasswordToken\n\n\n\n\nConfiguring Security with \nsecurity.yml\n\n\nSecurity configurations can be handled with a simple yml file. This file can be found in \nrepository/Config/security.yml\n.\n\n\nfirewalls:\n    bb_area:\n        pattern: ^/\n        requirements:\n            HTTP-X-Requested-With: XMLHttpRequest\n            HTTP-X-BB-METHOD: (JsonRpc|Upload)\n        provider: bb_user\n        bb_auth:\n            provider: bb_user\n            nonce_dir: security/nonces\n            lifetime: 1800\n            use_registry: true\n\nproviders:\n    bb_user:\n        entity:\n            class: BackBee\\Security\\User\n        secret: %secret_key%\n    public_key:\n        entity:\n            class: BackBee\\Security\\User\n\ncontexts:\n    BackBee\\Security\\Context: [StatelessContext, AnonymousContext, BBAuthContext, UsernamePasswordContext, LogoutContext, RestfulContext]\n\nencoders:\n    BackBee\\Security\\User:\n        class: Symfony\\Component\\Security\\Core\\Encoder\\MessageDigestPasswordEncoder\n        arguments:\n            algorithm: md5\n            encode_as_base64: false\n            iterations: 1\n\nacl:\n    connection: default", 
            "title": "Security"
        }, 
        {
            "location": "/developper-documentation/components/security/#components", 
            "text": "", 
            "title": "Components"
        }, 
        {
            "location": "/developper-documentation/components/security/#the-security-component", 
            "text": "BackBee  Security component is based on the Security Component of  Symfony .  It provides a robust way to secure a web application. Here we will present some of the core concepts of this component :  firewall ,  FirewallMap ,  authentication  ,  authorization ,  DecissionAccess ,   Voter ,  SecurityContext .", 
            "title": "The Security component"
        }, 
        {
            "location": "/developper-documentation/components/security/#overview-of-security-mechanism", 
            "text": "The main propose of the security component is to deal with  authentication  and  authorization .  Authentication is a way to grant access to a ressource. When a user is successfully authentified, authorization is a way to control access to a specific ressource.  Authentication is handled by what is called a  firewall . A application can have many secured areas, an admin area by instance.  A secured area is determined by an  url . When an url that is part of a secured area is requested, behind the hook some registered callbacks are executed.  The  Firewall  archives this by listening to the  symfony   kernel.request  event triggered by the HttpKernel.\nA  FirewallMap   that maps a  request  with the registered listeners then checks if the current request is under a secured area or is already secured.  A  FirewallMap  Listener can authenticate a request, throws an  AuthenticationException  or do nothing. If one of these listener throws an exception meaning that the request is not authentificated, this exception can either be transformed into an  AccessDeniedHttpException  or used to initiate an authentication process by calling the  Firewall  entry point.", 
            "title": "Overview of security mechanism"
        }, 
        {
            "location": "/developper-documentation/components/security/#authentication", 
            "text": "A firewall entry point, as it implements the  authenticationEntryPointInterface , must provided a  start  method which takes two parameters: a request and the exception previously raised.  start  must returns a  Response  object that can be a page showing a form by instance.\nIf one the FirewallMap Listener can handle the request, it creates a  Token  object that holds a reference to the current user, his role and his credentials.\nThe listener then uses an  authenticationProviderManager  object to authenticate the  Token .  authenticationProviderManager  will authenticate the token if provided and return an  authenticated  one if the user credential is valid.  Otherwise an  AuthenticationException  is raised.\nEach  Token  uses a specific type of  authenticationProvider . An  authenticationProvider  must implements the  authenticationProviderInterface  and provides the two methods :   authentificate  which takes one paramater that must implements the  TokenInterface  and  supports  which is used to check rather or not the given  token  is supported by the authentication provider .  Registered FirewallMap Listeners must implement the  ListenerInterface  thus provided an  handle  method that accept an  GetRequestEvent  object.", 
            "title": "Authentication"
        }, 
        {
            "location": "/developper-documentation/components/security/#authorization", 
            "text": "Once a user is identified his roles or any other attributes or object of its  token  can be used to determine rather or not he has access to a resource.  Decision manager  An  AccessControlManager  is used for making final access decisions based on  Voter .  A voter can decide to  vote  either for grant or deny access to a ressource. A voter can also abstrain itself.  By default The  AccessControllerManagers  make his decision according to one these three strategies:   affirmative  (Access is granted if any voter votes for granting access)  consensus  (Access is granted if there are more voters willing to granting access then otherwise  unanimous  (Access is granted if all voters vote for granting access)   Understand voters  A voter class must implements the  VoterInterface  which has 4 methods:   supportsAttribute($attribute)  supportsClass($class)  vote(TokentInterface $token, $object, $attributes)   supportsAttribute  is used to check if the voter supports some attributes of the token. supportClass  is user to check it the voter supports a specific class vote  handle the vote strategy and must return of those class Constant :   VoterInterface::ACCESS_GRANTED  VoterInterface::ACCESS_ABSTAIN  VoterInterface::ACCESS_DENIED   Bellow is list of Voter used in BackBee\n- AccessVoter\n- BBAclVoter\n- BBRoleVoter\n- SudoVoter", 
            "title": "Authorization"
        }, 
        {
            "location": "/developper-documentation/components/security/#backbee-securitycontext-and-the-contextinterface", 
            "text": "All the process of creating  Firewall ,  FirewallMap ,  AuthenticationManager ,  AccessDecisionMananger  and listeners is handled by the  BackBee\\Security\\SecurityContext  object.  However to way of dealing with security Listerners is simplyfied by using a  Context  object.\nA security  Context  extends the abstract class  BackBee\\Security\\Context\\BBAuthContext  and defines the  loadListeners  method.  LoadListeners  accepts one parameter which is the security config that can be setted is  repository/Config/security.yml . A context can be used to instanciate new listener or to register new authentication provider to the  SecuriryContext .  Bellow we show all the  security contexts provided by BackBee.   AnonymousContext  BBAuthContext  LogoutContext  RestfulContext  StatelessContext  UsernamePasswordContext   AnonymousContext  AnonymouseContext  is used to identify anonymous user.   authentication provider  :  BackBee\\Security\\Authentication\\Provider\\AnonymousAuthenticationProvider  Listener :  BackBee\\Security\\Listeners\\AnonymousAuthenticationListener  Token  :  BackBee\\Security\\Token\\AnonymousToken   BBAuthContext  BBAuthContext  is used to authentify a user by using the BackBee User table.   authentication provider  :  BackBee\\Security\\Authentication\\Provider\\BBAuthenticationProvider  Listener :  BackBee\\Security\\Listeners\\AnonymousAuthenticationListener  Token  :  BackBee\\Security\\Token\\BBUserToken   LogoutContext  LogoutContext  handles user logout by removing all setted tokens.   authentication provider  :  none  Token  :  none  Listener :  BackBee\\Security\\Listeners\\LogoutListener   RestfulContext  RestfulContext  is used to authentify rest user with a plublic key.   authentication provider :  BackBee\\Security\\Listeners\\PublicKeyAuthenticationProvider  Listener  :  BackBee\\Security\\Listeners\\PublicKeyAuthenticationListener  Token :  BackBee\\Security\\Token\\BBUserToken   StatelessContext  In stateless mode authentication is asked for every requests.  StatelessContext  handles sessions\ncreation every time stateless mode is disabled.   authentication provider :  none  Listener :  BackBee\\Security\\Listeners\\ContextListener  Token :  none   UsernamePasswordContext  UsernamePasswordContext is used to authenticate user by using a login form.   authentication provider :  BackBee\\Security\\Listeners\\Provider\\UserAuthenticationProvider  Listener :  BackBee\\Security\\Listeners\\UsernamePasswordAuthenticationListener  Token :  BackBee\\Security\\Token\\UsernamePasswordToken", 
            "title": "BackBee SecurityContext and the ContextInterface"
        }, 
        {
            "location": "/developper-documentation/components/security/#configuring-security-with-securityyml", 
            "text": "Security configurations can be handled with a simple yml file. This file can be found in  repository/Config/security.yml .  firewalls:\n    bb_area:\n        pattern: ^/\n        requirements:\n            HTTP-X-Requested-With: XMLHttpRequest\n            HTTP-X-BB-METHOD: (JsonRpc|Upload)\n        provider: bb_user\n        bb_auth:\n            provider: bb_user\n            nonce_dir: security/nonces\n            lifetime: 1800\n            use_registry: true\n\nproviders:\n    bb_user:\n        entity:\n            class: BackBee\\Security\\User\n        secret: %secret_key%\n    public_key:\n        entity:\n            class: BackBee\\Security\\User\n\ncontexts:\n    BackBee\\Security\\Context: [StatelessContext, AnonymousContext, BBAuthContext, UsernamePasswordContext, LogoutContext, RestfulContext]\n\nencoders:\n    BackBee\\Security\\User:\n        class: Symfony\\Component\\Security\\Core\\Encoder\\MessageDigestPasswordEncoder\n        arguments:\n            algorithm: md5\n            encode_as_base64: false\n            iterations: 1\n\nacl:\n    connection: default", 
            "title": "Configuring Security with security.yml"
        }, 
        {
            "location": "/developper-documentation/components/classcontent/", 
            "text": "Components\n\n\nThe ClassContent component\n\n\nClassContent Parameters\n\n\nParameters allow to configure your content easily, he is used usually in the listener but can be used everywhere. Parameters is contributed on front by the user with the gearing button of block.\n\n\nParameters is builded from the block's YAML like\n\n\nBlockDemo:\n    properties:\n        name: Block demo\n        description: \nBlock for demonstration purposes\n\n        category: [Demo]\n    elements:\n        text:\n            type: BackBee\\ClassContent\\Element\\Text\n    parameters:\n        mytext:\n            label: 'My text'\n            type: 'text'\n            value: ''\n        myselect:\n            label: 'My select'\n            type: 'select'\n            options:\n                'foo': 'Foo'\n                'bar': 'Bar'\n            value: ['foo']\n\n\n\n\n\nUse parameters\n\n\nIf parameters is not validated by user the content parameters is overrided by revision parameters.\n\nOnly value of the parameter is saved.\n\n\nFor get default parameters:\n\n\n?php\n$params = $content-\ngetDefaultParams();\n\n/** That return all parameters with definitions and default values:\n *  array (size=2)\n *    'mytext' =\n\n *      array (size=3)\n *        'label' =\n string 'My text' (length=7)\n *        'type' =\n string 'text' (length=4)\n *        'value' =\n string '' (length=0)\n *    'myselect' =\n\n *      array (size=4)\n *        'label' =\n string 'My select' (length=9)\n *        'type' =\n string 'select' (length=6)\n *        'options' =\n\n *          array (size=2)\n *            'foo' =\n string 'Foo' (length=3)\n *            'bar' =\n string 'Bar' (length=3)string 'yolo' (length=4)\n *        'value' =\n\n *          array (size=1)\n *            0 =\n string 'foo' (length=3)\n */\n\n\n\n\nFor get all parameters :\n\n\n?php\n\n$params = $content-\ngetAllParams();\n\n/** That return all parameters with definitions and new values\n *  array (size=2)\n *    'mytext' =\n\n *      array (size=3)\n *        'label' =\n string 'My text' (length=7)\n *        'type' =\n string 'text' (length=4)\n *        'value' =\n string '' (length=0)\n *    'myselect' =\n\n *      array (size=4)\n *        'label' =\n string 'My select' (length=9)\n *        'type' =\n string 'select' (length=6)\n *        'options' =\n\n *          array (size=2)\n *            'foo' =\n string 'Foo' (length=3)\n *            'bar' =\n string 'Bar' (length=3)\n *        'value' =\n\n *          array (size=1)\n *            0 =\n string 'foo' (length=3)\n */\n\n\n\n\nFor get one param:\n\n\n?php\n$param = $content-\ngetParam('mytext');\n\n/** That return the definition and new value\n *  array (size=3)\n *    'label' =\n string 'My text' (length=7)\n *    'type' =\n string 'text' (length=4)\n *    'value' =\n string '' (length=0)\n */\n\n\n\n\nFor get the value of the param:\n\n\n?php\n$paramValue = $content-\ngetParamValue('mytext');\n\n// That return the new value string '' (length=0)\n\n\n\n\nFor set a value, you need to set a same type which you declare in YAML file as value:\n\n\n?php\n$content-\nsetParam('mytext', 'foo');\n$param = $content-\ngetParamValue('mytext')\n\n// That return a new value set  string 'foo' (length=3)\n\n\n\n\nParameters reference\n\n\n\n\ncheckbox\n\n\ndatetimepicker\n\n\nhidden\n\n\nlinkSelector\n\n\nmediaSelector\n\n\nnodeSelector\n\n\npassword\n\n\nradio\n\n\nselect\n\n\ntext\n\n\ntextarea\n\n\n\n\nAll parameters has default options:\n\n\nDefault options\n\n\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\nDefault\n\n\nMandatory\n\n\n\n\n\n\n\n\n\n\nlabel\n\n\nString\n\n\nLabel is display above the field\n\n\nEmpty\n\n\nNo\n\n\n\n\n\n\nvalue\n\n\nMixed\n\n\nThis field must be set and allow to describe type of the  parameter\n\n\nNone\n\n\nYes\n\n\n\n\n\n\ntype\n\n\nString\n\n\nKey of one of available parameters\n\n\nNone\n\n\nYes\n\n\n\n\n\n\n\n\n\n\nCheckbox\n\n\nLike HTML checkbox attribute\n\n\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\nDefault\n\n\nMandatory\n\n\n\n\n\n\n\n\n\n\noptions\n\n\nArray\n\n\nList of options (key/value)\n\n\nEmpty array\n\n\nYes\n\n\n\n\n\n\ninline\n\n\nBoolean\n\n\nDisplay checkbox inline\n\n\nfalse\n\n\nNo\n\n\n\n\n\n\nvalue\n\n\nArray\n\n\nList of selected checkboxes\n\n\nEmpty array\n\n\nYes\n\n\n\n\n\n\n\n\nExample\n:\n\n\nparameters:\n    mycheckbox:\n        type: 'checkbox'\n        options:\n            'foo': 'Foo'\n            'bar': 'Bar'\n        value: ['foo']\n        inline: true\n\n\n\n\n?php\n$param = $content-\ngetParamValue('mycheckbox'); // sarray('foo')\n\n\n\n\n\n\nDatetime picker\n\n\nElement text with a datetimepicker\n\n\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\nDefault\n\n\nMandatory\n\n\n\n\n\n\n\n\n\n\nvalue\n\n\nNumber\n\n\nIt is an timestamp value\n\n\nEmpty\n\n\nYes\n\n\n\n\n\n\n\n\nExample\n:\n\n\nparameters:\n    mydatetimepicker:\n        type: 'datetimepicker'\n        value: 1435573740\n\n\n\n\n?php\n$param = $content-\ngetParamValue('mydatetimepicker'); //return 1435573740\n\n\n\n\n\n\nHidden\n\n\nLike HTML hidden attribute\n\n\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\nDefault\n\n\nMandatory\n\n\n\n\n\n\n\n\n\n\nvalue\n\n\nString\n\n\nThe default text\n\n\nEmpty\n\n\nYes\n\n\n\n\n\n\n\n\nExample\n:\n\n\nparameters:\n    myhidden:\n        type: 'hidden'\n        value: 'foo'\n\n\n\n\n?php\n$param = $content-\ngetParamValue('myhidden'); // foo\n\n\n\n\n\n\nLink selector\n\n\nLink selector allow to choose a link from tree page or external link.\n\n\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\nDefault\n\n\nMandatory\n\n\n\n\n\n\n\n\n\n\nvalue\n\n\nJson\n\n\nObject which contains url / title / pageUid / target\n\n\nEmpty array\n\n\nYes\n\n\n\n\n\n\n\n\nExample\n:\n\n\nparameters:\n    mylinkselector:\n        type: 'linkSelector'\n        value: []\n\n\n\n\n?php\n# Example with select one link\n$param = $content-\ngetParamValue('mylinkselector');\n// array('url' =\n '/foo', 'title' =\n 'Foo', 'pageUid' =\n 'anPageUid', 'target' =\n '_self')\n\n\n\n\n Page tree \n:\nWe recommend to retrieve the url from the page entity instead of the url attribute cause the url can change.\n\n\n External link \n :\nIn this case, note the pageUid attribute is (obviously) null.\n\n\n\n\nMedia selector\n\n\nMedia selector allow to choose a list of media from the media library.\n\n\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\nDefault\n\n\nMandatory\n\n\n\n\n\n\n\n\n\n\nvalue\n\n\nJson\n\n\nObject which contains folder_uid / image / media_id / title /type / uid\n\n\nEmpty array\n\n\nYes\n\n\n\n\n\n\n\n\nExample\n:\n\n\nparameters:\n    mymediaselector:\n        type: 'mediaSelector'\n        value: []\n\n\n\n\n?php\n# Example with select one media\n$param = $content-\ngetParamValue('mymediaselector');\n// array(array('folder_uid' =\n 'anFolderUid', 'image' =\n 'imageUrl', 'media_id' =\n '1', 'title' =\n '_Foo', 'type' =\n 'Media/Image', 'uid' =\n 'anUid'))\n\n\n\n\n\n\nNode selector\n\n\nNode selector allow to choose a page from tree\n\n\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\nDefault\n\n\nMandatory\n\n\n\n\n\n\n\n\n\n\nvalue\n\n\nJson\n\n\nObject which contains url  pageUid / title\n\n\nEmpty array\n\n\nYes\n\n\n\n\n\n\n\n\nExample\n:\n\n\nparameters:\n    mynodeselector:\n        type: 'nodeSelector'\n        value: []\n\n\n\n\n# Example with select one node\n$param = $content-\ngetParamValue('mynodeselector');\n# array('pageUid' =\n 'anPageUid', 'title' =\n 'Foo')\n\n\n\n\nWe recommend to retrieve the title from the page entity instead of the title attribute cause the title can change.\n\n\n\n\nPassword\n\n\nLike HTML password attribute\n\n\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\nDefault\n\n\nMandatory\n\n\n\n\n\n\n\n\n\n\nvalue\n\n\nString\n\n\nThe default text\n\n\nEmpty\n\n\nYes\n\n\n\n\n\n\n\n\nExample\n:\n\n\nparameters:\n    mypassword:\n        type: 'password'\n        value: 'foo'\n\n\n\n\n?php\n$param = $content-\ngetParamValue('mypassword'); // foo\n\n\n\n\n\n\nRadio\n\n\nLike HTML radio attribute\n\n\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\nDefault\n\n\nMandatory\n\n\n\n\n\n\n\n\n\n\noptions\n\n\nArray\n\n\nList of options (key/value)\n\n\nEmpty array\n\n\nYes\n\n\n\n\n\n\ninline\n\n\nBoolean\n\n\nDisplay radio inline\n\n\nfalse\n\n\nNo\n\n\n\n\n\n\nvalue\n\n\nArray\n\n\nList of selected radio\n\n\nEmpty array\n\n\nYes\n\n\n\n\n\n\n\n\nExample\n:\n\n\nparameters:\n    myradio:\n        type: 'radio'\n        options:\n            'foo': 'Foo'\n            'bar': 'Bar'\n        value: ['foo']\n        inline: true\n\n\n\n\n?php\n$param = $content-\ngetParamValue('myradio'); // array('foo')\n\n\n\n\n\n\nSelect\n\n\nLike HTML select attribute\n\n\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\nDefault\n\n\nMandatory\n\n\n\n\n\n\n\n\n\n\noptions\n\n\nArray\n\n\nList of options (key/value)\n\n\nEmpty array\n\n\nYes\n\n\n\n\n\n\nvalue\n\n\nArray\n\n\nList of selected radio\n\n\nEmpty array\n\n\nYes\n\n\n\n\n\n\nmultiple\n\n\nBoolean\n\n\nAllow to multiple selection\n\n\nfalse\n\n\nNo\n\n\n\n\n\n\n\n\nExample\n:\n\n\nparameters:\n    mypassword:\n        type: 'select'\n        options:\n            'foo': 'Foo'\n            'bar': 'Bar'\n        value: ['foo']\n        multiple: true\n\n\n\n\n?php\n$param = $content-\ngetParamValue('myradio'); //array('foo')\n\n\n\n\n\n\nText\n\n\nLike HTML text attribute\n\n\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\nDefault\n\n\nMandatory\n\n\n\n\n\n\n\n\n\n\nvalue\n\n\nString\n\n\nThe default text\n\n\nEmpty\n\n\nYes\n\n\n\n\n\n\n\n\nExample\n:\n\n\nparameters:\n    mytext:\n        type: 'text'\n        value: 'foo'\n\n\n\n\n?php\n$param = $content-\ngetParamValue('mypassword'); // foo\n\n\n\n\n\n\nTextarea\n\n\nLike HTML textearea attribute\n\n\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\nDefault\n\n\nMandatory\n\n\n\n\n\n\n\n\n\n\nvalue\n\n\nString\n\n\nThe default text\n\n\nEmpty\n\n\nYes\n\n\n\n\n\n\nrows\n\n\nString\n\n\nthe rows html attribute\n\n\n5\n\n\nNo\n\n\n\n\n\n\n\n\nExample\n:\n\n\nparameters:\n    mytextearea:\n        type: 'textarea'\n        value: 'BackBee'\n        rows: 10\n\n\n\n\n?php\n$param = $content-\ngetParamValue('mytextearea'); // BackBee\n\n\n\n\n\n\nSpecial parameters\n\n\nRendermode\n\n\nRendermode parameters allow to list automatically rendermodes of the content and use it directly.\n\n\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\nDefault\n\n\nMandatory\n\n\n\n\n\n\n\n\n\n\nvalue\n\n\nArray\n\n\nSelected rendermode\n\n\nEmpty\n\n\nYes\n\n\n\n\n\n\n\n\nparameters:\n    rendermode:\n        type: 'select'\n        value: []\n\n\n\n\nThe key must be 'rendermode'", 
            "title": "ClassContent"
        }, 
        {
            "location": "/developper-documentation/components/classcontent/#components", 
            "text": "", 
            "title": "Components"
        }, 
        {
            "location": "/developper-documentation/components/classcontent/#the-classcontent-component", 
            "text": "", 
            "title": "The ClassContent component"
        }, 
        {
            "location": "/developper-documentation/components/classcontent/#classcontent-parameters", 
            "text": "Parameters allow to configure your content easily, he is used usually in the listener but can be used everywhere. Parameters is contributed on front by the user with the gearing button of block.  Parameters is builded from the block's YAML like  BlockDemo:\n    properties:\n        name: Block demo\n        description:  Block for demonstration purposes \n        category: [Demo]\n    elements:\n        text:\n            type: BackBee\\ClassContent\\Element\\Text\n    parameters:\n        mytext:\n            label: 'My text'\n            type: 'text'\n            value: ''\n        myselect:\n            label: 'My select'\n            type: 'select'\n            options:\n                'foo': 'Foo'\n                'bar': 'Bar'\n            value: ['foo']  Use parameters  If parameters is not validated by user the content parameters is overrided by revision parameters. Only value of the parameter is saved.  For get default parameters:  ?php\n$params = $content- getDefaultParams();\n\n/** That return all parameters with definitions and default values:\n *  array (size=2)\n *    'mytext' = \n *      array (size=3)\n *        'label' =  string 'My text' (length=7)\n *        'type' =  string 'text' (length=4)\n *        'value' =  string '' (length=0)\n *    'myselect' = \n *      array (size=4)\n *        'label' =  string 'My select' (length=9)\n *        'type' =  string 'select' (length=6)\n *        'options' = \n *          array (size=2)\n *            'foo' =  string 'Foo' (length=3)\n *            'bar' =  string 'Bar' (length=3)string 'yolo' (length=4)\n *        'value' = \n *          array (size=1)\n *            0 =  string 'foo' (length=3)\n */  For get all parameters :  ?php\n\n$params = $content- getAllParams();\n\n/** That return all parameters with definitions and new values\n *  array (size=2)\n *    'mytext' = \n *      array (size=3)\n *        'label' =  string 'My text' (length=7)\n *        'type' =  string 'text' (length=4)\n *        'value' =  string '' (length=0)\n *    'myselect' = \n *      array (size=4)\n *        'label' =  string 'My select' (length=9)\n *        'type' =  string 'select' (length=6)\n *        'options' = \n *          array (size=2)\n *            'foo' =  string 'Foo' (length=3)\n *            'bar' =  string 'Bar' (length=3)\n *        'value' = \n *          array (size=1)\n *            0 =  string 'foo' (length=3)\n */  For get one param:  ?php\n$param = $content- getParam('mytext');\n\n/** That return the definition and new value\n *  array (size=3)\n *    'label' =  string 'My text' (length=7)\n *    'type' =  string 'text' (length=4)\n *    'value' =  string '' (length=0)\n */  For get the value of the param:  ?php\n$paramValue = $content- getParamValue('mytext');\n\n// That return the new value string '' (length=0)  For set a value, you need to set a same type which you declare in YAML file as value:  ?php\n$content- setParam('mytext', 'foo');\n$param = $content- getParamValue('mytext')\n\n// That return a new value set  string 'foo' (length=3)", 
            "title": "ClassContent Parameters"
        }, 
        {
            "location": "/developper-documentation/components/classcontent/#parameters-reference", 
            "text": "checkbox  datetimepicker  hidden  linkSelector  mediaSelector  nodeSelector  password  radio  select  text  textarea   All parameters has default options:  Default options      Type  Description  Default  Mandatory      label  String  Label is display above the field  Empty  No    value  Mixed  This field must be set and allow to describe type of the  parameter  None  Yes    type  String  Key of one of available parameters  None  Yes      Checkbox  Like HTML checkbox attribute      Type  Description  Default  Mandatory      options  Array  List of options (key/value)  Empty array  Yes    inline  Boolean  Display checkbox inline  false  No    value  Array  List of selected checkboxes  Empty array  Yes     Example :  parameters:\n    mycheckbox:\n        type: 'checkbox'\n        options:\n            'foo': 'Foo'\n            'bar': 'Bar'\n        value: ['foo']\n        inline: true  ?php\n$param = $content- getParamValue('mycheckbox'); // sarray('foo')   Datetime picker  Element text with a datetimepicker      Type  Description  Default  Mandatory      value  Number  It is an timestamp value  Empty  Yes     Example :  parameters:\n    mydatetimepicker:\n        type: 'datetimepicker'\n        value: 1435573740  ?php\n$param = $content- getParamValue('mydatetimepicker'); //return 1435573740   Hidden  Like HTML hidden attribute      Type  Description  Default  Mandatory      value  String  The default text  Empty  Yes     Example :  parameters:\n    myhidden:\n        type: 'hidden'\n        value: 'foo'  ?php\n$param = $content- getParamValue('myhidden'); // foo   Link selector  Link selector allow to choose a link from tree page or external link.      Type  Description  Default  Mandatory      value  Json  Object which contains url / title / pageUid / target  Empty array  Yes     Example :  parameters:\n    mylinkselector:\n        type: 'linkSelector'\n        value: []  ?php\n# Example with select one link\n$param = $content- getParamValue('mylinkselector');\n// array('url' =  '/foo', 'title' =  'Foo', 'pageUid' =  'anPageUid', 'target' =  '_self')   Page tree  :\nWe recommend to retrieve the url from the page entity instead of the url attribute cause the url can change.   External link   :\nIn this case, note the pageUid attribute is (obviously) null.   Media selector  Media selector allow to choose a list of media from the media library.      Type  Description  Default  Mandatory      value  Json  Object which contains folder_uid / image / media_id / title /type / uid  Empty array  Yes     Example :  parameters:\n    mymediaselector:\n        type: 'mediaSelector'\n        value: []  ?php\n# Example with select one media\n$param = $content- getParamValue('mymediaselector');\n// array(array('folder_uid' =  'anFolderUid', 'image' =  'imageUrl', 'media_id' =  '1', 'title' =  '_Foo', 'type' =  'Media/Image', 'uid' =  'anUid'))   Node selector  Node selector allow to choose a page from tree      Type  Description  Default  Mandatory      value  Json  Object which contains url  pageUid / title  Empty array  Yes     Example :  parameters:\n    mynodeselector:\n        type: 'nodeSelector'\n        value: []  # Example with select one node\n$param = $content- getParamValue('mynodeselector');\n# array('pageUid' =  'anPageUid', 'title' =  'Foo')  We recommend to retrieve the title from the page entity instead of the title attribute cause the title can change.   Password  Like HTML password attribute      Type  Description  Default  Mandatory      value  String  The default text  Empty  Yes     Example :  parameters:\n    mypassword:\n        type: 'password'\n        value: 'foo'  ?php\n$param = $content- getParamValue('mypassword'); // foo   Radio  Like HTML radio attribute      Type  Description  Default  Mandatory      options  Array  List of options (key/value)  Empty array  Yes    inline  Boolean  Display radio inline  false  No    value  Array  List of selected radio  Empty array  Yes     Example :  parameters:\n    myradio:\n        type: 'radio'\n        options:\n            'foo': 'Foo'\n            'bar': 'Bar'\n        value: ['foo']\n        inline: true  ?php\n$param = $content- getParamValue('myradio'); // array('foo')   Select  Like HTML select attribute      Type  Description  Default  Mandatory      options  Array  List of options (key/value)  Empty array  Yes    value  Array  List of selected radio  Empty array  Yes    multiple  Boolean  Allow to multiple selection  false  No     Example :  parameters:\n    mypassword:\n        type: 'select'\n        options:\n            'foo': 'Foo'\n            'bar': 'Bar'\n        value: ['foo']\n        multiple: true  ?php\n$param = $content- getParamValue('myradio'); //array('foo')   Text  Like HTML text attribute      Type  Description  Default  Mandatory      value  String  The default text  Empty  Yes     Example :  parameters:\n    mytext:\n        type: 'text'\n        value: 'foo'  ?php\n$param = $content- getParamValue('mypassword'); // foo   Textarea  Like HTML textearea attribute      Type  Description  Default  Mandatory      value  String  The default text  Empty  Yes    rows  String  the rows html attribute  5  No     Example :  parameters:\n    mytextearea:\n        type: 'textarea'\n        value: 'BackBee'\n        rows: 10  ?php\n$param = $content- getParamValue('mytextearea'); // BackBee   Special parameters  Rendermode  Rendermode parameters allow to list automatically rendermodes of the content and use it directly.      Type  Description  Default  Mandatory      value  Array  Selected rendermode  Empty  Yes     parameters:\n    rendermode:\n        type: 'select'\n        value: []  The key must be 'rendermode'", 
            "title": "Parameters reference"
        }
    ]
}