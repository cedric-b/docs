{
    "docs": [
        {
            "location": "/", 
            "text": "Introduction\n\n\nWhat is BackBee ?\n\n\nBackBee is an open source Content Management System (CMS) with one major advantage. BackBee uses On-page Editing Technology (OET) which means you can easily create and manage websites as they appear with no prior technical knowledge.\n\n\nWhat is an Open-page Editing Site?\n\n\nOn-page Editing Technology (OET) is the natural evolution of your usual Content Management System functionalities. On-page Editing Technology is a tool that allows you to enter, edit and manage your website directly as it appears to users: The back office and front office are merged.\n\n\nWhat's this means?\n\n\nIn most content management systems, you have to shuttle between the back office \u2013 a functional interface \u2013 and a \u201cpreview\u201d mode. This is the only way for you to see what users will.\n\n\nBackBee\u2019s On-Page Editing Technology lets you directly do all your inputting and editing on the page that appears to users. Therefore you get an immediate and exact idea of what the final page will look like eliminating all unnecessary operations.\n\n\nWhat\u2019s so interesting about this?\n\n\nIt's easier and more flexible than your usual CMS. With BackBee's On-page Editing Technology, you can work directly on your HTML page, the page that's visible to users. You can drag and drop page elements and move them around as you wish, adding, deleting or changing text, photos or other page elements by simply clicking on the area in question.\n\n\nThe majority of the editorial functions are present in one single compact toolbar on top of your website page. BackBee is the first CMS to use On-Page editing Technology merging back office and front office.\n\n\nKey concepts\n\n\n\n\nIt\u2019s unimaginably easy to use.\n\n\nResponsive design is native to the app.\n\n\nIt\u2019s super flexible in terms of graphic design, workflow, SEO and user access.\n\n\nIt's secure, in several senses: it saves changes so that editorial security is guaranteed; it's easy to configure user access and rights; and the BackBee core is very secure, so developers can make contributions fearlessly.\n\n\nIt\u2019s open source, which means it\u2019s constantly being tested and improved.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#introduction", 
            "text": "", 
            "title": "Introduction"
        }, 
        {
            "location": "/#what-is-backbee", 
            "text": "BackBee is an open source Content Management System (CMS) with one major advantage. BackBee uses On-page Editing Technology (OET) which means you can easily create and manage websites as they appear with no prior technical knowledge.  What is an Open-page Editing Site?  On-page Editing Technology (OET) is the natural evolution of your usual Content Management System functionalities. On-page Editing Technology is a tool that allows you to enter, edit and manage your website directly as it appears to users: The back office and front office are merged.  What's this means?  In most content management systems, you have to shuttle between the back office \u2013 a functional interface \u2013 and a \u201cpreview\u201d mode. This is the only way for you to see what users will.  BackBee\u2019s On-Page Editing Technology lets you directly do all your inputting and editing on the page that appears to users. Therefore you get an immediate and exact idea of what the final page will look like eliminating all unnecessary operations.  What\u2019s so interesting about this?  It's easier and more flexible than your usual CMS. With BackBee's On-page Editing Technology, you can work directly on your HTML page, the page that's visible to users. You can drag and drop page elements and move them around as you wish, adding, deleting or changing text, photos or other page elements by simply clicking on the area in question.  The majority of the editorial functions are present in one single compact toolbar on top of your website page. BackBee is the first CMS to use On-Page editing Technology merging back office and front office.", 
            "title": "What is BackBee ?"
        }, 
        {
            "location": "/#key-concepts", 
            "text": "It\u2019s unimaginably easy to use.  Responsive design is native to the app.  It\u2019s super flexible in terms of graphic design, workflow, SEO and user access.  It's secure, in several senses: it saves changes so that editorial security is guaranteed; it's easy to configure user access and rights; and the BackBee core is very secure, so developers can make contributions fearlessly.  It\u2019s open source, which means it\u2019s constantly being tested and improved.", 
            "title": "Key concepts"
        }, 
        {
            "location": "/developper-documentation/requirements/", 
            "text": "Developper documentation\n\n\nRequirements for running BackBee CMS\n\n\nTo run BackBee CMS, your system needs to fulfill to a list of requirements.\n\n\nHere you will find the list of required and optional requirements.\n\n\nRequired\n\n\nBecause BackBee CMS is built on top of Symfony components, theses elements are required.\n\n\n\n\nJSON\n needs to be enabled\n\n\nctype\n needs to be enabled\n\n\nmbstring\n needs to be enabled\n\n\nYour php configuration needs to have the date.timezone setting completed\n\n\n\n\nThe mibimum version of PHP must be: \nPHP 5.4.0\n.\n\n\nOptional\n\n\n\n\nYou (may) need to have the PHP-XML module installed\n\n\nYou (may) need to have at least version 2.6.21 of libxml\n\n\nYou (may) need to have PHP tokenizer module enabled\n\n\nYou (may) need to have iconv module enabled\n\n\nYou (may) need to have POSIX enabled (only on *nix)\n\n\nYou (may) need to have Intl installed with ICU 4+\n\n\nYou (may) need to have APC 3.0.17+ installed (or another opcode cache needs to be installed)\n\n\nphp configuration recommended settings:\n\n\n\n\nshort_open_tag = Off\n\nmagic_quotes_gpc = Off\n\nregister_globals = Off\n\nsession.auto_start = Off\n\n\n\n\nDoctrine2 (Database management)\n\n\nBecause we depend on Doctrine 2, you will need to have PDO installed. Additionally, you need to have the PDO driver installed to use your database server.\nAlso, you need \nphp5-sqlite\n extension to be installed and enabled during the installation process.", 
            "title": "Requirements"
        }, 
        {
            "location": "/developper-documentation/requirements/#developper-documentation", 
            "text": "", 
            "title": "Developper documentation"
        }, 
        {
            "location": "/developper-documentation/requirements/#requirements-for-running-backbee-cms", 
            "text": "To run BackBee CMS, your system needs to fulfill to a list of requirements.  Here you will find the list of required and optional requirements.  Required  Because BackBee CMS is built on top of Symfony components, theses elements are required.   JSON  needs to be enabled  ctype  needs to be enabled  mbstring  needs to be enabled  Your php configuration needs to have the date.timezone setting completed   The mibimum version of PHP must be:  PHP 5.4.0 .  Optional   You (may) need to have the PHP-XML module installed  You (may) need to have at least version 2.6.21 of libxml  You (may) need to have PHP tokenizer module enabled  You (may) need to have iconv module enabled  You (may) need to have POSIX enabled (only on *nix)  You (may) need to have Intl installed with ICU 4+  You (may) need to have APC 3.0.17+ installed (or another opcode cache needs to be installed)  php configuration recommended settings:   short_open_tag = Off\n\nmagic_quotes_gpc = Off\n\nregister_globals = Off\n\nsession.auto_start = Off  Doctrine2 (Database management)  Because we depend on Doctrine 2, you will need to have PDO installed. Additionally, you need to have the PDO driver installed to use your database server.\nAlso, you need  php5-sqlite  extension to be installed and enabled during the installation process.", 
            "title": "Requirements for running BackBee CMS"
        }, 
        {
            "location": "/developper-documentation/installation/", 
            "text": "Developper documentation\n\n\nInstallation\n\n\nMake sure you have basic knowledge of PHP5, Apache or Nginx and MySQL to install BackBee in developper mode.\n\n\nThird party Software\n\n\nFirst of all, you need to check that your computer has an appropriate working environment for web development. You need at least a web server (Apache, for instance), a database engine (MySQL, PostgreSQL, SQLite, or any PDO-compatible database engine), and \nPHP 5.4\n.\n\n\nYou need to install \ngit\n and \nComposer\n, the dependency manager for PHP.\n\n\nIf your are on Linux/Unix based (like ubuntu or Mac OS X), follow this \nlink\n for installation. Composer is also available on \nWindows system\n.\n\n\nIn a command line interface, check if \ncomposer\n is correctly installed:\n\n\n\n\nAlso, check your PHP version which should be 5.4 or more.\n\n\n\n\nSet up a domain name in your operating system.\nOn Unix/Linux based OS, you can add it into \n/etc/hosts\n file. In our example: \nblogbee.dev\n:\n\n\n127.0.0.1   blogbee.dev\n\n\n\nYou can now launch the installation process.\n\n\nWeb Installer\n\n\nOpen a command line interface and get BackBee:\n\n\n$ composer create-project \"backbee/backbee-standard\" /path/to/your/folder \"1.0\" -n\n\n\n\nThen on the \npublic\n directory, launch the builtin server of PHP:\n\n\n$ cd /path/to/your/folder/public \n php -S blogbee.dev:8000\n\n\n\nAnd you should see the first installation step of BackBee (access \nhttp://localhost:8000/install.php\n) in a web browser:\n\n\n\n\nYou need to create \ncache\n and \nlog\n folders with the correct rights, then you can refresh the page and access to the \nsecond step\n of the installer.\n\n\n\n\nIf required, check the \nrepository/Config\n folder rights and then go to the \nthird\n step.\n\n\nYou need to set your database settings. If you use a different database engine than MySQL or MariaDB, set the correct driver else you have nothing to change, only fill the fields \ndatabase name\n, \nusername\n and \npassword\n.\n\n\n\n\nYou also need to define your super admin user, fill the credentials then save and continue to the \nfourth\n step.\n\n\n\n\nBackBee Installer creates and populates the database, fill the last fields to complete the installation process: the \nsite_name\n and the \ndomain\n.\n\n\n\n\nInstallation is now completed: BackBee gives you the \nApache\n or \nNginx\n configuration you have to set up to be able to use BackBee on the chosen domain.\n\n\n\n\n\n\nWhen your web server is set up, access the site by going to \nhttp://blogbee.dev\n.\n\n\nIf everything is correctly installed, you should see the BackBee welcome message:\n\n\n\n\n\n\nIf you can't see BackBee welcome message, make sure that \ncache\n and \nlog\n folders have the correct rights. (755 or 777)\n\n\n\n\nYou can now enter your new backoffice buy pressing  \nCTRL + ALT + B\n. Fill the login dialog with the credentials you have set up in the fourth step.", 
            "title": "Installation"
        }, 
        {
            "location": "/developper-documentation/installation/#developper-documentation", 
            "text": "", 
            "title": "Developper documentation"
        }, 
        {
            "location": "/developper-documentation/installation/#installation", 
            "text": "Make sure you have basic knowledge of PHP5, Apache or Nginx and MySQL to install BackBee in developper mode.  Third party Software  First of all, you need to check that your computer has an appropriate working environment for web development. You need at least a web server (Apache, for instance), a database engine (MySQL, PostgreSQL, SQLite, or any PDO-compatible database engine), and  PHP 5.4 .  You need to install  git  and  Composer , the dependency manager for PHP.  If your are on Linux/Unix based (like ubuntu or Mac OS X), follow this  link  for installation. Composer is also available on  Windows system .  In a command line interface, check if  composer  is correctly installed:   Also, check your PHP version which should be 5.4 or more.   Set up a domain name in your operating system.\nOn Unix/Linux based OS, you can add it into  /etc/hosts  file. In our example:  blogbee.dev :  127.0.0.1   blogbee.dev  You can now launch the installation process.  Web Installer  Open a command line interface and get BackBee:  $ composer create-project \"backbee/backbee-standard\" /path/to/your/folder \"1.0\" -n  Then on the  public  directory, launch the builtin server of PHP:  $ cd /path/to/your/folder/public   php -S blogbee.dev:8000  And you should see the first installation step of BackBee (access  http://localhost:8000/install.php ) in a web browser:   You need to create  cache  and  log  folders with the correct rights, then you can refresh the page and access to the  second step  of the installer.   If required, check the  repository/Config  folder rights and then go to the  third  step.  You need to set your database settings. If you use a different database engine than MySQL or MariaDB, set the correct driver else you have nothing to change, only fill the fields  database name ,  username  and  password .   You also need to define your super admin user, fill the credentials then save and continue to the  fourth  step.   BackBee Installer creates and populates the database, fill the last fields to complete the installation process: the  site_name  and the  domain .   Installation is now completed: BackBee gives you the  Apache  or  Nginx  configuration you have to set up to be able to use BackBee on the chosen domain.    When your web server is set up, access the site by going to  http://blogbee.dev .  If everything is correctly installed, you should see the BackBee welcome message:    If you can't see BackBee welcome message, make sure that  cache  and  log  folders have the correct rights. (755 or 777)   You can now enter your new backoffice buy pressing   CTRL + ALT + B . Fill the login dialog with the credentials you have set up in the fourth step.", 
            "title": "Installation"
        }, 
        {
            "location": "/developper-documentation/architecture/", 
            "text": "Developper documentation\n\n\nArchitecture\n\n\nBackBee CMS relies on many Symfony components and Doctrine 2.\n\n\nHere is the list of components currently used by BackBee CMS:\n\n\n\n\nConfig\n\n\nConsole\n\n\nDebug\n\n\nDependencyInjection\n\n\nEventDispatcher\n\n\nExpression Language\n\n\nFilesystem\n\n\nHttpFoundation\n\n\nHttpKernel\n\n\nRouting\n\n\nSecurity ACL\n\n\nSecurity Core\n\n\nSecurity HTTP\n\n\nSerializer\n\n\nTranslation\n\n\nValidator\n\n\nYaml\n\n\n(Twig)\n\n\n\n\nBackBee CMS is based on a PHP application (the BackBee \"Core\") which provides a REST API managing all the contents,\nthe users, the media and the security. A REST Javascript client provides user interface.\n\n\nTo understand how BackBee CMS is built, take a look on this schema:", 
            "title": "Architecture"
        }, 
        {
            "location": "/developper-documentation/architecture/#developper-documentation", 
            "text": "", 
            "title": "Developper documentation"
        }, 
        {
            "location": "/developper-documentation/architecture/#architecture", 
            "text": "BackBee CMS relies on many Symfony components and Doctrine 2.  Here is the list of components currently used by BackBee CMS:   Config  Console  Debug  DependencyInjection  EventDispatcher  Expression Language  Filesystem  HttpFoundation  HttpKernel  Routing  Security ACL  Security Core  Security HTTP  Serializer  Translation  Validator  Yaml  (Twig)   BackBee CMS is based on a PHP application (the BackBee \"Core\") which provides a REST API managing all the contents,\nthe users, the media and the security. A REST Javascript client provides user interface.  To understand how BackBee CMS is built, take a look on this schema:", 
            "title": "Architecture"
        }, 
        {
            "location": "/developper-documentation/configuration/", 
            "text": "Developper documentation\n\n\nConfiguration\n\n\nBackBee CMS is powerful and highly configurable.\nIn this section, all the available configurations are broken down by the key (e.g. doctrine) that defines each possible section of your application configuration.\n\n\nBootstrap configuration (bootstrap.yml)\n\n\nThis configuration file has only two functions:\n\n\n\n\ndebug\n: set the developper mode: if \ntrue\n, the container is generated at each request.\n\n\ncontainer\n: set the container configuration which have 2 parameters\n\n\ndump_directory\n: set the location of the generated container.\n\n\nautogenerate\n: if true, the container is generated at each request.\n\n\n\n\n\n\n\n\nThe \nautogenerate\n option is useful when you want to force the generation of the container in \"production\". Don't forget this option has a performance cost.\n\n\nBundles configuration (bundles.yml)\n\n\nTo activate a bundle, you need to register it in this file:\n\n\n# /repository/Config/bundles.yml\ndemo: BackBee\\Bundle\\DemoBundle\\Demo\ntoolbar: BackBee\\Bundle\\ToolbarBundle\\Toolbar\n\n\n\n\n\nDatabase configuration (doctrine.yml)\n\n\nWe provide a demo sample configuration. You can see all available parameters into the related \nDoctrine configuration of Symfony\n:\n\n\n# /repository/Config/doctrine.yml\ndbal:\n    driver: pdo_mysql # [mysql|pgsql|sqlite]\n    host: localhost\n    port: 3306\n    dbname: backbee\n    user: root\n    password: password\n    charset: utf8\n    collation: utf8_general_ci\n    defaultTableOptions: { collate: utf8_general_ci, engine: InnoDB, charset: utf8 }\norm:\n    auto_mapping: true\n    metadata_cache_driver: apc\n    query_cache_driver:\n        type: service\n        id: my_doctrine_common_cache_service # must be a service or a FQCN\n    result_cache_driver:\n        type: memcache\n        host: localhost\n        port: 11211\n        instance_class: Memcache\n\n\n\n\n\nSEO Configuration (metadata.yml)\n\n\nThis is where you set up the HTML meta headers you want to configure for each page of BackBee:\n\n\n# /repository/Config/metadata.yml\nkeywords:\n    name: 'keywords'\n    content:\n        default: 'cms, content manager'\ndescription:\n    name: 'description'\n    content:\n        default: \nbackbee demo website\n\n    lang: 'en'\nrobots:\n    name: 'robots'\n    content:\n        default: ''\n        select: ['', 'noindex', 'nofollow', 'noindex, nofollow']\n\n\n\n\n\nThis configuration has a real impact on the toolbar, see the generated SEO form in Page context mode:\n\n\n\n\nSecurity Configuration (security.yml)\n\n\nYou can set up firewalls and sudoers inside this file. A sudoer is a super administrator:\n\n\n# /repository/Config/security.yml\nfirewalls:\n    firewall_name: { pattern: ^/, anonymous: null }\nsudoers:\n    username: userId", 
            "title": "Configuration"
        }, 
        {
            "location": "/developper-documentation/configuration/#developper-documentation", 
            "text": "", 
            "title": "Developper documentation"
        }, 
        {
            "location": "/developper-documentation/configuration/#configuration", 
            "text": "BackBee CMS is powerful and highly configurable.\nIn this section, all the available configurations are broken down by the key (e.g. doctrine) that defines each possible section of your application configuration.  Bootstrap configuration (bootstrap.yml)  This configuration file has only two functions:   debug : set the developper mode: if  true , the container is generated at each request.  container : set the container configuration which have 2 parameters  dump_directory : set the location of the generated container.  autogenerate : if true, the container is generated at each request.     The  autogenerate  option is useful when you want to force the generation of the container in \"production\". Don't forget this option has a performance cost.  Bundles configuration (bundles.yml)  To activate a bundle, you need to register it in this file:  # /repository/Config/bundles.yml\ndemo: BackBee\\Bundle\\DemoBundle\\Demo\ntoolbar: BackBee\\Bundle\\ToolbarBundle\\Toolbar  Database configuration (doctrine.yml)  We provide a demo sample configuration. You can see all available parameters into the related  Doctrine configuration of Symfony :  # /repository/Config/doctrine.yml\ndbal:\n    driver: pdo_mysql # [mysql|pgsql|sqlite]\n    host: localhost\n    port: 3306\n    dbname: backbee\n    user: root\n    password: password\n    charset: utf8\n    collation: utf8_general_ci\n    defaultTableOptions: { collate: utf8_general_ci, engine: InnoDB, charset: utf8 }\norm:\n    auto_mapping: true\n    metadata_cache_driver: apc\n    query_cache_driver:\n        type: service\n        id: my_doctrine_common_cache_service # must be a service or a FQCN\n    result_cache_driver:\n        type: memcache\n        host: localhost\n        port: 11211\n        instance_class: Memcache  SEO Configuration (metadata.yml)  This is where you set up the HTML meta headers you want to configure for each page of BackBee:  # /repository/Config/metadata.yml\nkeywords:\n    name: 'keywords'\n    content:\n        default: 'cms, content manager'\ndescription:\n    name: 'description'\n    content:\n        default:  backbee demo website \n    lang: 'en'\nrobots:\n    name: 'robots'\n    content:\n        default: ''\n        select: ['', 'noindex', 'nofollow', 'noindex, nofollow']  This configuration has a real impact on the toolbar, see the generated SEO form in Page context mode:   Security Configuration (security.yml)  You can set up firewalls and sudoers inside this file. A sudoer is a super administrator:  # /repository/Config/security.yml\nfirewalls:\n    firewall_name: { pattern: ^/, anonymous: null }\nsudoers:\n    username: userId", 
            "title": "Configuration"
        }, 
        {
            "location": "/developper-documentation/project_architecture/", 
            "text": "Developper documentation\n\n\nProject Architecture\n\n\nGlobal Architecture\n\n\nGlobal Architecture is build by default by BackBee, it's compose the folders:\n- \nbundle\n optional folder, create it only if you want develop your own bundle. By default the bundle is installed into the vendor folder\n- \ncache\n optional  and can be placed out of the project and is location have to be specified into \nservices.yml\n into the \nConfig\n folder.\n- \nlog\n same as cache folder\n- \npublic\n folder it is the document root of your website\n- \nrepository\n The folder where you customize your project it's more develop after\n- \nvendor\n folder build by composer where you can find every dependencies\n\n\nRepository folder Architecture\n\n\nRepository folder (writhed \nrepository\n) is certainly the most important folder of your project, is in this folder where you will customize entirely your BackBee project. If you start from standard edition you have some folder available, but you can add lot of more and we are going to enumerate every folder it's possible to add (Take note of you have to respect the Case).\n\n\n\n\n\n\nClassContent\n This folder contains your contents definitions\n\n\n\n\n\n\nConfig\n Here you can find and override each config file of BackBee\n\n\n\n\n\n\nController\n In this folder your controller will be automatically auto-loaded\n\n\n\n\n\n\nData\n Folder where every uploaded file are stored. Against cache and log folder, data can moved out of the project by customizing \nservices.yml\n\n\n\n\n\n\nLayouts\n Layouts template are stored in this folder.\n\n\n\n\n\n\nListener\n In this folder your Event Listeners will be automatically auto-loaded.\n\n\n\n\n\n\nResources\n In this folder you put your statics files like images, JS scripts and CSS.\n\n\n\n\n\n\nTemplates\n Folder where you put your helpers into \nhelpers\n subfolder, partials into \npartials\n subfolder and ClassContent templates into \nscripts\n subfolder.\n\n\n\n\n\n\nTraits\n In this folder your ClassContent's Trait will be automatically auto-loaded.\n\n\n\n\n\n\nTranslation\n Your translation catalog will automatically auto-loaded in this folder.\n\n\n\n\n\n\nContext and repository folder overriding\n\n\nIn BackBee repository folder can be contextualized. You use an contextualized repository when you start your application, it's the first parameter in construct method.\n\n\n?php\n$app = new \\BackBee\\Standard\\Application('newContext');\n// ...\n\n\n\n\nIf you initialize your application like this, you have the possibility to extend the entire repository folder. Before will see the repository folder architecture then you can reproduce it into your context.\n\n\nThe context repository, have to be created into the \nrepository\n folder and have the same name as the key you pass in first parameter of the Application.\n\n\nAfter this you override the file you want by reproducing the folder path and the file. And for the other element, you don't need to reproduce it, it will automatically inherited.\n\n\nrepository/\n  ClassContent/\n  Config/\n    doctrine.yml\n  Data/\n  Listener/\n  newContext/\n    Config/\n      doctrine.yml\n  Resources/\n  ...\n\n\n\n\nIn this case, doctrine configuration will be override to use an other database for example.\n\n\nrepository/\n  ClassContent/\n    AnContent.yml\n  ...\n  newContext/\n    ClassContent/\n      AnotherContent.yml\n  Resources/\n  ...\n\n\n\n\nIn this case the \"newContext\" instance have access to two type of ClassContent and the default configuration only one.\n\n\nAnd of course you can combine the two example.", 
            "title": "Project Architecture"
        }, 
        {
            "location": "/developper-documentation/project_architecture/#developper-documentation", 
            "text": "", 
            "title": "Developper documentation"
        }, 
        {
            "location": "/developper-documentation/project_architecture/#project-architecture", 
            "text": "Global Architecture  Global Architecture is build by default by BackBee, it's compose the folders:\n-  bundle  optional folder, create it only if you want develop your own bundle. By default the bundle is installed into the vendor folder\n-  cache  optional  and can be placed out of the project and is location have to be specified into  services.yml  into the  Config  folder.\n-  log  same as cache folder\n-  public  folder it is the document root of your website\n-  repository  The folder where you customize your project it's more develop after\n-  vendor  folder build by composer where you can find every dependencies  Repository folder Architecture  Repository folder (writhed  repository ) is certainly the most important folder of your project, is in this folder where you will customize entirely your BackBee project. If you start from standard edition you have some folder available, but you can add lot of more and we are going to enumerate every folder it's possible to add (Take note of you have to respect the Case).    ClassContent  This folder contains your contents definitions    Config  Here you can find and override each config file of BackBee    Controller  In this folder your controller will be automatically auto-loaded    Data  Folder where every uploaded file are stored. Against cache and log folder, data can moved out of the project by customizing  services.yml    Layouts  Layouts template are stored in this folder.    Listener  In this folder your Event Listeners will be automatically auto-loaded.    Resources  In this folder you put your statics files like images, JS scripts and CSS.    Templates  Folder where you put your helpers into  helpers  subfolder, partials into  partials  subfolder and ClassContent templates into  scripts  subfolder.    Traits  In this folder your ClassContent's Trait will be automatically auto-loaded.    Translation  Your translation catalog will automatically auto-loaded in this folder.    Context and repository folder overriding  In BackBee repository folder can be contextualized. You use an contextualized repository when you start your application, it's the first parameter in construct method.  ?php\n$app = new \\BackBee\\Standard\\Application('newContext');\n// ...  If you initialize your application like this, you have the possibility to extend the entire repository folder. Before will see the repository folder architecture then you can reproduce it into your context.  The context repository, have to be created into the  repository  folder and have the same name as the key you pass in first parameter of the Application.  After this you override the file you want by reproducing the folder path and the file. And for the other element, you don't need to reproduce it, it will automatically inherited.  repository/\n  ClassContent/\n  Config/\n    doctrine.yml\n  Data/\n  Listener/\n  newContext/\n    Config/\n      doctrine.yml\n  Resources/\n  ...  In this case, doctrine configuration will be override to use an other database for example.  repository/\n  ClassContent/\n    AnContent.yml\n  ...\n  newContext/\n    ClassContent/\n      AnotherContent.yml\n  Resources/\n  ...  In this case the \"newContext\" instance have access to two type of ClassContent and the default configuration only one.  And of course you can combine the two example.", 
            "title": "Project Architecture"
        }, 
        {
            "location": "/developper-documentation/cookbooks/create_bundle_administration/", 
            "text": "CookBooks\n\n\nCreate bundle administration\n\n\nConfiguration :\n\n\nTo create an bundle administration we need to declare some parameters into the bundle configuration. Then open your config file into \nConfig/config.yml\n\n\nDefine your controller\n\n\nbundle:\n  ...\n  admin_controller:\n    doc: BackBee\\Bundle\\DocumentationBundle\\Controller\\DocController\n\n\n\n\n\n\nYou can declare controller as much as you want.\n\n\n\n\nbundle:\n  ...\n  admin_controller:\n    first: BackBee\\Bundle\\DocumentationBundle\\Controller\\FirstController\n    second: BackBee\\Bundle\\DocumentationBundle\\Controller\\SecondController\n    ...\n\n\n\n\nAnd to finish we need to define the entry point of your admin interface.\n\n\nbundle:\n  ...\n  admin_entry_point: doc.index\n\n\n\n\n\n\nThe entry point it's compose by controller name that refer the name you declare in \nadmin_controller\n section, dot separator and action name without the Action key word index refer to \nindexAction\n.\n\n\n\n\nController and Actions\n\n\nYour admin controller class have to extend \nAbstractAdminBundleController\n to work correctly in automated mode.\n\n\n?php\nnamespace BackBee\\Bundle\\DocumentationBundle\\Controller;\nuse BackBee\\Bundle\\AbstractAdminBundleController;\n\nclass DocController extends AbstractAdminBundleController\n{\n}\n\n\n\n\n\n\nThis represent the minimum necessary to implement your admin controller.\n\n\n\n\nBy extending \nAbstractAdminBundleController\n your controller can access to lot of methods:\n\n\n\n\ngetApplication()\n Returns current application\n\n\ngetContainer()\nReturns the dependency injection container\n\n\ngetRequest()\n Returns current request\n\n\ngetEntityManager()\n Returns doctrine entity manager\n\n\ngetRepository($entity)\n Returns the repository corresponding of the entity name passed in paramater\n\n\nisGranted($permission, $object)\n Returns true if the current user have the permission to do the action on the object\n\n\ngetTranslator()\n Returns translator object\n\n\nrender($template, $parameters)\n Returns template parsed and rendered first argument is the template file starting from your rendering folder and $parameters are the variables necessary to render the template.\n\n\ncreateResponse($content, $statusCode, $contentType)\n Generate your own response, $content parameter is the body of the response, $statusCode correspond to the\n\n\nredirect($url, $statusCode)\n Create a redirection response\n\n\nnotifyUser($type, $message)\n Generate an notification on the backoffice to the user there is 3 types availble \nself::NOTIFY_SUCCESS\n (green), \nself::NOTIFY_WARNING\n (orange) and \nself::NOTIFY_ERROR\n (red).\n\n\n\n\nNow you have to implement some actions in your controller by default an action have to return an \nString\n, before we have defined that the entry point of the bundle administration it was do in the \nindexAction\n.\nThe index action return an array of values and need no parameters to work, \nindexAction\n it's compose of an \nfindAll\n and one \nrender\n\n\npublic function indexAction()\n{\n    $docs = $this-\ngetRepository('BackBee\\Bundle\\DocumentationBundle\\Entity\\Item')-\nfindAll();\n\n    return $this-\nrender('Doc/Index.twig', ['docs' =\n $docs]);\n}\n\n\n\n\nTo consult one object doc in particular we need an showAction. This action need an identifier to retrieve the good object and render it.\n\n\npublic function showAction($id)\n{\n    $doc = $this-\ngetRepository('BackBee\\Bundle\\DocumentationBundle\\Entity\\Item')-\nfind($id);\n\n    return $this-\nrender('Doc/Doc.twig', ['doc' =\n $doc]);\n}\n\n\n\n\nRouting\n\n\nBy default on all application, you to expose some route and do the matching with an controller and an action. In the bundle administration the routing is dynamic and automatic. To generate the URL you have 3 helpers to render the URL into your template.\nImplicit route are defined like this: \nRoute is composed by the bundle name, controller name and action name separated by a dot\n.\n\n\n\n\nIn the case of the method \nshowAction\n from \nDocController\n into \nDocumentationBundle\n the route is equal to \ndocumentation.doc.show\n. \ndocumentation\n matches to the name declared into \nbundle.yml\n file in your global configuration and \ndoc\n is the name you gave to your controller into admin_controller section of your \nconfig.yml\n into your bundle configuration file.\n\n\n\n\n\n\nbundleAdminUrl($route, $parameters)\n this helper generate your URL it need a \"route\" and optionally parameters.\n\n\nbundleAdminLink($route, $parameters, $httpMethod)\n this helper generate all value necessary to an automated system, it work like the previous helper, but accept an third parameter to specify the HTTP method you want use when the link was cliqued. By default the HTTP method is GET.\n\n\nbundleAdminForm($route, $parameters, $httpMethod)\n work like \nbundleAdminLink\n but by default the HTTP method is POST.\n\n\n\n\n\n\nbundleAdminLink\n  \nbundleAdminForm\n generate more than just an URL and it need to be goodly used.\n\n\nbundleAdminUrl\n is required only if you want create an custom system and bypass the automated system.\n\n\n\n\nUsage of the \nbundleAdminLink\n into an template to reach the \nshowAction\n\n\na {{ this.bundleAdminLink(\ndocumentation.doc.show\n, {'id': 1})|raw }}\n\n    Show the first document\n\n/a\n\n\n\n\n\nAnd the result before rendering is:\n\n\na data-bundle=\nlink\n href=\n/bundle/documentation/doc/show/1\n data-http-method=\nread\n\n   Show the first document\n\n/a\n\n\n\n\n\n\n\nAs you can see the id 1 do part of the URL and is not present as query. This is because your \nshowAction\n method require an $id to work and the helper do automatically the matching behind the action and your parameters.\n\n\nIn the case of \nbundleAdminForm\n, this helper work correctly only in \nform\n HTML tag.", 
            "title": "Create bundle administration"
        }, 
        {
            "location": "/developper-documentation/cookbooks/create_bundle_administration/#cookbooks", 
            "text": "", 
            "title": "CookBooks"
        }, 
        {
            "location": "/developper-documentation/cookbooks/create_bundle_administration/#create-bundle-administration", 
            "text": "Configuration :  To create an bundle administration we need to declare some parameters into the bundle configuration. Then open your config file into  Config/config.yml  Define your controller  bundle:\n  ...\n  admin_controller:\n    doc: BackBee\\Bundle\\DocumentationBundle\\Controller\\DocController   You can declare controller as much as you want.   bundle:\n  ...\n  admin_controller:\n    first: BackBee\\Bundle\\DocumentationBundle\\Controller\\FirstController\n    second: BackBee\\Bundle\\DocumentationBundle\\Controller\\SecondController\n    ...  And to finish we need to define the entry point of your admin interface.  bundle:\n  ...\n  admin_entry_point: doc.index   The entry point it's compose by controller name that refer the name you declare in  admin_controller  section, dot separator and action name without the Action key word index refer to  indexAction .   Controller and Actions  Your admin controller class have to extend  AbstractAdminBundleController  to work correctly in automated mode.  ?php\nnamespace BackBee\\Bundle\\DocumentationBundle\\Controller;\nuse BackBee\\Bundle\\AbstractAdminBundleController;\n\nclass DocController extends AbstractAdminBundleController\n{\n}   This represent the minimum necessary to implement your admin controller.   By extending  AbstractAdminBundleController  your controller can access to lot of methods:   getApplication()  Returns current application  getContainer() Returns the dependency injection container  getRequest()  Returns current request  getEntityManager()  Returns doctrine entity manager  getRepository($entity)  Returns the repository corresponding of the entity name passed in paramater  isGranted($permission, $object)  Returns true if the current user have the permission to do the action on the object  getTranslator()  Returns translator object  render($template, $parameters)  Returns template parsed and rendered first argument is the template file starting from your rendering folder and $parameters are the variables necessary to render the template.  createResponse($content, $statusCode, $contentType)  Generate your own response, $content parameter is the body of the response, $statusCode correspond to the  redirect($url, $statusCode)  Create a redirection response  notifyUser($type, $message)  Generate an notification on the backoffice to the user there is 3 types availble  self::NOTIFY_SUCCESS  (green),  self::NOTIFY_WARNING  (orange) and  self::NOTIFY_ERROR  (red).   Now you have to implement some actions in your controller by default an action have to return an  String , before we have defined that the entry point of the bundle administration it was do in the  indexAction .\nThe index action return an array of values and need no parameters to work,  indexAction  it's compose of an  findAll  and one  render  public function indexAction()\n{\n    $docs = $this- getRepository('BackBee\\Bundle\\DocumentationBundle\\Entity\\Item')- findAll();\n\n    return $this- render('Doc/Index.twig', ['docs' =  $docs]);\n}  To consult one object doc in particular we need an showAction. This action need an identifier to retrieve the good object and render it.  public function showAction($id)\n{\n    $doc = $this- getRepository('BackBee\\Bundle\\DocumentationBundle\\Entity\\Item')- find($id);\n\n    return $this- render('Doc/Doc.twig', ['doc' =  $doc]);\n}  Routing  By default on all application, you to expose some route and do the matching with an controller and an action. In the bundle administration the routing is dynamic and automatic. To generate the URL you have 3 helpers to render the URL into your template.\nImplicit route are defined like this:  Route is composed by the bundle name, controller name and action name separated by a dot .   In the case of the method  showAction  from  DocController  into  DocumentationBundle  the route is equal to  documentation.doc.show .  documentation  matches to the name declared into  bundle.yml  file in your global configuration and  doc  is the name you gave to your controller into admin_controller section of your  config.yml  into your bundle configuration file.    bundleAdminUrl($route, $parameters)  this helper generate your URL it need a \"route\" and optionally parameters.  bundleAdminLink($route, $parameters, $httpMethod)  this helper generate all value necessary to an automated system, it work like the previous helper, but accept an third parameter to specify the HTTP method you want use when the link was cliqued. By default the HTTP method is GET.  bundleAdminForm($route, $parameters, $httpMethod)  work like  bundleAdminLink  but by default the HTTP method is POST.    bundleAdminLink    bundleAdminForm  generate more than just an URL and it need to be goodly used.  bundleAdminUrl  is required only if you want create an custom system and bypass the automated system.   Usage of the  bundleAdminLink  into an template to reach the  showAction  a {{ this.bundleAdminLink( documentation.doc.show , {'id': 1})|raw }} \n    Show the first document /a   And the result before rendering is:  a data-bundle= link  href= /bundle/documentation/doc/show/1  data-http-method= read \n   Show the first document /a    As you can see the id 1 do part of the URL and is not present as query. This is because your  showAction  method require an $id to work and the helper do automatically the matching behind the action and your parameters.  In the case of  bundleAdminForm , this helper work correctly only in  form  HTML tag.", 
            "title": "Create bundle administration"
        }, 
        {
            "location": "/developper-documentation/cookbooks/create_new_commands/", 
            "text": "CookBooks\n\n\nCreate new commands\n\n\nThe Console page of the Components section covers how to create a console application.\nThis cookbook article covers the creation of a command using BackBee Standard Edition.\n\n\nAutomatically Registering Commands\n\n\nTo make the console commands available automatically with BackBee, create a\n\nCommand\n directory inside your bundle and create a PHP file suffixed with\n\nCommand.php\n for each command that you want to provide. For example, if you\nwant to extend the DemoBundle to welcome you from the command line, create\n\nWelcomeCommand.php\n and add the following to it:\n\n\n// bundle/WelcomeBundle/Command/WelcomeCommand.php\nnamespace WelcomeBundle\\Command;\n\nuse Symfony\\Component\\Console\\Input\\InputInterface;\nuse Symfony\\Component\\Console\\Input\\InputArgument;\nuse Symfony\\Component\\Console\\Input\\InputOption;\nuse Symfony\\Component\\Console\\Output\\OutputInterface;\n\n\nuse BackBee\\Console\\AbstractCommand;\n\nclass WelcomeCommand extends AbstractCommand\n{\n    protected function configure()\n    {\n        $this\n            -\nsetName('demo:welcome')\n            -\nsetDescription('Welcome someone')\n            -\naddArgument(\n                'name',\n                InputArgument::OPTIONAL,\n                'Who do you want to welcome?'\n            )\n            -\naddOption(\n                'yell',\n                null,\n                InputOption::VALUE_NONE,\n                'If set, the message will yell in uppercase letters'\n            )\n            -\nsetHelp(\nEOF\nThe \ninfo\n%command.name%\n/info\n command can welcome someone.\nWith the option ``yell``, the message will be displayed in uppercase letters.\nEOF;\n            )\n        ;\n    }\n\n    protected function execute(InputInterface $input, OutputInterface $output)\n    { \n        $text = 'Welcome '.$input-\ngetArgument('name');\n\n        if ($input-\ngetOption('yell')) {\n            $text = strtoupper($text);\n        }\n\n        $output-\nwriteln($text);\n    }\n}\n\n\n\n\nThis command will now automatically be available to run:\n\n\n    $ ./backbee demo:welcome Charles", 
            "title": "Create new commands"
        }, 
        {
            "location": "/developper-documentation/cookbooks/create_new_commands/#cookbooks", 
            "text": "", 
            "title": "CookBooks"
        }, 
        {
            "location": "/developper-documentation/cookbooks/create_new_commands/#create-new-commands", 
            "text": "The Console page of the Components section covers how to create a console application.\nThis cookbook article covers the creation of a command using BackBee Standard Edition.  Automatically Registering Commands  To make the console commands available automatically with BackBee, create a Command  directory inside your bundle and create a PHP file suffixed with Command.php  for each command that you want to provide. For example, if you\nwant to extend the DemoBundle to welcome you from the command line, create WelcomeCommand.php  and add the following to it:  // bundle/WelcomeBundle/Command/WelcomeCommand.php\nnamespace WelcomeBundle\\Command;\n\nuse Symfony\\Component\\Console\\Input\\InputInterface;\nuse Symfony\\Component\\Console\\Input\\InputArgument;\nuse Symfony\\Component\\Console\\Input\\InputOption;\nuse Symfony\\Component\\Console\\Output\\OutputInterface;\n\n\nuse BackBee\\Console\\AbstractCommand;\n\nclass WelcomeCommand extends AbstractCommand\n{\n    protected function configure()\n    {\n        $this\n            - setName('demo:welcome')\n            - setDescription('Welcome someone')\n            - addArgument(\n                'name',\n                InputArgument::OPTIONAL,\n                'Who do you want to welcome?'\n            )\n            - addOption(\n                'yell',\n                null,\n                InputOption::VALUE_NONE,\n                'If set, the message will yell in uppercase letters'\n            )\n            - setHelp( EOF\nThe  info %command.name% /info  command can welcome someone.\nWith the option ``yell``, the message will be displayed in uppercase letters.\nEOF;\n            )\n        ;\n    }\n\n    protected function execute(InputInterface $input, OutputInterface $output)\n    { \n        $text = 'Welcome '.$input- getArgument('name');\n\n        if ($input- getOption('yell')) {\n            $text = strtoupper($text);\n        }\n\n        $output- writeln($text);\n    }\n}  This command will now automatically be available to run:      $ ./backbee demo:welcome Charles", 
            "title": "Create new commands"
        }, 
        {
            "location": "/developper-documentation/cookbooks/create_new_templating_helpers/", 
            "text": "CookBooks\n\n\nCreate new templating Helpers\n\n\nThis cookbook article covers the creation of Renderer helpers using BackBee Standard Edition.\n\n\nTemplating helpers are PHP classes that extend the \nfinal\n class \nBackBee\\Renderer\\AbstractRenderer\\AbstractHelper\n,\nand need to be located in \nrepository/Templates/helpers\n folder in your BackBee application (or in \nTemplates/helpers\n folder in bundles).\n\n\nAs an example, we will create an helper to provide a new \nbb_dump()\n function in templates.\n\n\n\n\nYou need to create class with the same name as the function you want to create, because \n__invoke\n magic function is called.\n\n\n\n\n?php\nnamespace BackBee\\Renderer\\Helper;\n\n/**\n * @author Micka\u00ebl Andrieu \nmickael.andrieu@lp-digital.fr\n\n */\nclass bb_dump extends AbstractHelper\n{\n    /**\n     * Returns dump from template (to ease debug of Class Content rendering)\n     * If Symfony VarDumper is autoaded, use it instead of Doctrine Debug::dump()\n     *\n     * @param  mixin $mixin the variable to dump\n     *\n     * @return string\n     */\n    public function __invoke($mixin)\n    {\n        if (!class_exists('\\Symfony\\Component\\VarDumper\\VarDumper')) {\n            return '\npre\n' . \\Doctrine\\Common\\Util\\Debug::dump($mixin, 2, true, false) . '\n/pre\n';\n        }else {\n            return dump($mixin);\n        }\n    }\n}\n\n\n\n\nThe helper is done and can used directly in all templates.\n\n\n!-- /repository/Templates/scripts/Home/HomeContainer --\n\n\ndiv {{ this.bbcontent(null, {'class': 'container main_containt'})|raw }}\n\n\n    {% if this.getObject().getParamValue('container_title') != '' %}\n        \ndiv class=\nbloc-title-2 triangle-b\n\n          \ndiv class=\nborder-bx2 border-color color-txt-1\n{{ this.getObject().getParamValue('container_title') }}\n/div\n\n        \n/div\n\n    {% endif %}\n\n    {{ this.render(container)|raw }}\n\n    {{ this.bb_dump(this.getObject())|raw }}\n\n/div\n\n\n\n\n\nor, in phtml:\n\n\n!-- in a pHTML template --\n\n\np\n\n\n?php $this-\nbb_dump($this-\ngetObject()); ?\n\n\n/p\n\n\n\n\n\nWill produce, with the \n[Symfony VarDumper](http://symfony.com/doc/current/components/var_dumper/introduction.html)\n added as dependency of project,\nthis output:", 
            "title": "Create new templating helpers"
        }, 
        {
            "location": "/developper-documentation/cookbooks/create_new_templating_helpers/#cookbooks", 
            "text": "", 
            "title": "CookBooks"
        }, 
        {
            "location": "/developper-documentation/cookbooks/create_new_templating_helpers/#create-new-templating-helpers", 
            "text": "This cookbook article covers the creation of Renderer helpers using BackBee Standard Edition.  Templating helpers are PHP classes that extend the  final  class  BackBee\\Renderer\\AbstractRenderer\\AbstractHelper ,\nand need to be located in  repository/Templates/helpers  folder in your BackBee application (or in  Templates/helpers  folder in bundles).  As an example, we will create an helper to provide a new  bb_dump()  function in templates.   You need to create class with the same name as the function you want to create, because  __invoke  magic function is called.   ?php\nnamespace BackBee\\Renderer\\Helper;\n\n/**\n * @author Micka\u00ebl Andrieu  mickael.andrieu@lp-digital.fr \n */\nclass bb_dump extends AbstractHelper\n{\n    /**\n     * Returns dump from template (to ease debug of Class Content rendering)\n     * If Symfony VarDumper is autoaded, use it instead of Doctrine Debug::dump()\n     *\n     * @param  mixin $mixin the variable to dump\n     *\n     * @return string\n     */\n    public function __invoke($mixin)\n    {\n        if (!class_exists('\\Symfony\\Component\\VarDumper\\VarDumper')) {\n            return ' pre ' . \\Doctrine\\Common\\Util\\Debug::dump($mixin, 2, true, false) . ' /pre ';\n        }else {\n            return dump($mixin);\n        }\n    }\n}  The helper is done and can used directly in all templates.  !-- /repository/Templates/scripts/Home/HomeContainer --  div {{ this.bbcontent(null, {'class': 'container main_containt'})|raw }} \n\n    {% if this.getObject().getParamValue('container_title') != '' %}\n         div class= bloc-title-2 triangle-b \n           div class= border-bx2 border-color color-txt-1 {{ this.getObject().getParamValue('container_title') }} /div \n         /div \n    {% endif %}\n\n    {{ this.render(container)|raw }}\n\n    {{ this.bb_dump(this.getObject())|raw }} /div   or, in phtml:  !-- in a pHTML template --  p  ?php $this- bb_dump($this- getObject()); ?  /p   Will produce, with the  [Symfony VarDumper](http://symfony.com/doc/current/components/var_dumper/introduction.html)  added as dependency of project,\nthis output:", 
            "title": "Create new templating Helpers"
        }, 
        {
            "location": "/developper-documentation/cookbooks/customize_error_pages/", 
            "text": "CookBooks\n\n\nCustomize error pages\n\n\nIn BackBee, thanks to Symfony Debug component all errors are treated as exceptions: pages not found or access unauthorized.\nEach error is triggered by throwing an exception in your code.\n\n\nIn \"Developper Mode\" BackBee will catch and display a \nbetter\n exception page with a lot of informations\nto help you understand the issue:\n\n\n\n\nIn production, your visitors will see the nice error page provided by BackBee:\n\n\n\n\nError pages can be customized in two different ways depending on your needs:\n\n\n\n\nIf you just want to design the contents and styles of the error pages, you can set your own error templates\n\n\nIf you need total control of exception handling to execute your own logic, create your own ExceptionListener on \nkernel.exception\n event.\n\n\n\n\nUse your own default templates\n\n\nWhen the error page loads, an internal ExceptionListener is used to render a Twig template to show template to the user.\n\n\nThis ExceptionListener uses the HTTP status code, the \ndebug\n parameter and the following logic to determine the template filename:\n\n\nBackBee provides core templates which are located into \nvendor/backbee/BackBee/Resources/layouts/error\n.\nIf the template for the code status doesn't exist, the default template which be used instead.\n\n\nIn BackBee Standard edition, theses templates are already overriden in the \nToolbarBundle\n. Theses templates are located\ninto \nvendor/backbee/toolbar-bundle/Resources/layouts/error\n folder.\n\n\nIf you want to override theses templates, your application might look like this:\n\n\nrepository/\n    Resources/\n        layouts/\n            error/\n                404.phtml\n                500.twig\n                default.phtml\n\n\n\n\nIn case you need them, the ExceptionController passes informations to the error template via the error variable.\nIt acts as the original PHP exception so you can access the HTTP status code and exception message.", 
            "title": "Customize error pages"
        }, 
        {
            "location": "/developper-documentation/cookbooks/customize_error_pages/#cookbooks", 
            "text": "", 
            "title": "CookBooks"
        }, 
        {
            "location": "/developper-documentation/cookbooks/customize_error_pages/#customize-error-pages", 
            "text": "In BackBee, thanks to Symfony Debug component all errors are treated as exceptions: pages not found or access unauthorized.\nEach error is triggered by throwing an exception in your code.  In \"Developper Mode\" BackBee will catch and display a  better  exception page with a lot of informations\nto help you understand the issue:   In production, your visitors will see the nice error page provided by BackBee:   Error pages can be customized in two different ways depending on your needs:   If you just want to design the contents and styles of the error pages, you can set your own error templates  If you need total control of exception handling to execute your own logic, create your own ExceptionListener on  kernel.exception  event.   Use your own default templates  When the error page loads, an internal ExceptionListener is used to render a Twig template to show template to the user.  This ExceptionListener uses the HTTP status code, the  debug  parameter and the following logic to determine the template filename:  BackBee provides core templates which are located into  vendor/backbee/BackBee/Resources/layouts/error .\nIf the template for the code status doesn't exist, the default template which be used instead.  In BackBee Standard edition, theses templates are already overriden in the  ToolbarBundle . Theses templates are located\ninto  vendor/backbee/toolbar-bundle/Resources/layouts/error  folder.  If you want to override theses templates, your application might look like this:  repository/\n    Resources/\n        layouts/\n            error/\n                404.phtml\n                500.twig\n                default.phtml  In case you need them, the ExceptionController passes informations to the error template via the error variable.\nIt acts as the original PHP exception so you can access the HTTP status code and exception message.", 
            "title": "Customize error pages"
        }, 
        {
            "location": "/developper-documentation/cookbooks/ease_debugging_with_profiler/", 
            "text": "CookBooks\n\n\nEase debugging with Profiler\n\n\nIn BackBee, in addition to the Symfony Debug which display a \nbetter\n exception page with more informations, we have\naccess to a Profiler which collect a lot of interesting data to help developper understand what is going on.\n\n\nThis article cookbook covers the documentation of actual panels from BackBee Profiler.\n\n\nThe BackBee Profiler is a toolbar available at the bottom of the page when you are in \"development\" mode.\n\n\n\n\nFrom left to right, you access to useful informations:\n\n the \nBackBee CMS\n version and the \nBackBee CMS\n application name;\n\n the code status of the page and the action used to render the page;\n\n the number of logs generated when render this page;\n\n the memory used to render the page (in Mo);\n* the number of database requests and the time spent to execute them.\n\n\nThe \nConfiguration\n panel\n\n\nWhen you click on \nBackBee CMS\n version or application name, you access the \nConfiguration panel\n.\n\n\nIn this panel, informations from BackBee configuration are displayed:\n\n\nProject configuration\n\n\nIn this section, the version of BackBee CMS used, the application name and the environment are displayed.\n\n\nPHP configuration\n\n\nIn this section, the version of PHP used is displayed and informations about cache extensions.\nAlso, click on \"phpinfo\" will give you full informations about your PHP configuration.\n\n\nActives Bundle\n\n\nIn this section are listed all activated bundles (i.e exactly the same results as bundles registered in \nbundles.yml\n file).\n\n\nThe \nRequest\n panel\n\n\nWhen you click on status code or in the action used to render page, you open the \nRequest panel\n.\n\n\nIn this panel, all informations from server and from Symfony Request object are displayed to help you understand the\ninformations used to render your page.\n\n\nAll the informations from PHP super globals related to the Request are displayed.\n\n\n\n\nGET\n and \nPOST\n parameters;\n\n\nRequest attributes from BackBee:\n\n\n_action\n: the action used to render the page;\n\n\n_controller\n: the controller called to render the page;\n\n\n_route\n: the route matched by the uri;\n\n\nuri\n: if not controller was found, return \"\nroot\n\" which means the BackBee \nFrontController\n is used.\n\n\n\n\n\n\nRequest cookies;\n\n\nRequest headers (also availables in debug toolbar from any web browser)\n\n\nRequest content\n\n\nRequest Server parameters:\n\n\nResponse headers;\n\n\n\n\nBut also, the \nSession\n informations and the \nflashes\n messages\n\n\nThe \nRouting\n panel\n\n\nWhen you click on \"Routing\", you open the \nRequest panel\n.\n\n\nIn addition to the \ndebug:routing\n command available in \nDebugBundle\n, the Routing panel provides a global overview of actual routes\nregistered in the application.\n\n\nRoutes are ordered by name, schema and patterns. For each route, the panel list the Controller/action couple called when the route is accessed.\n\n\n\n\nThis is a good way to discover the REST API.\n\n\n\n\nThe \nDatabase\n panel\n\n\nWhen you click on the database icon or in the database informations, you open the \nDatabase panel\n.\n\n\nQueries section\n\n\nThis panel list all Doctrine requests used to render the page with the spending time and the runnable query.\nThis is useful when you want to optimize SQL queries or want to understand why you have a Doctrine error with a \nQueryBuilder\n.\n\n\nDoctrine ORM mapping section\n\n\nIf you create your own entities and want to use Doctrine 2 to save in database, you need set up theses PHP classes.\nThis section display all actual classes managed by Doctrine 2 and if the mapping is correctly set up,\nelse an explicit message is displayed to help you fix the mapping.", 
            "title": "Ease debugging with the Web Profiler"
        }, 
        {
            "location": "/developper-documentation/cookbooks/ease_debugging_with_profiler/#cookbooks", 
            "text": "", 
            "title": "CookBooks"
        }, 
        {
            "location": "/developper-documentation/cookbooks/ease_debugging_with_profiler/#ease-debugging-with-profiler", 
            "text": "In BackBee, in addition to the Symfony Debug which display a  better  exception page with more informations, we have\naccess to a Profiler which collect a lot of interesting data to help developper understand what is going on.  This article cookbook covers the documentation of actual panels from BackBee Profiler.  The BackBee Profiler is a toolbar available at the bottom of the page when you are in \"development\" mode.   From left to right, you access to useful informations:  the  BackBee CMS  version and the  BackBee CMS  application name;  the code status of the page and the action used to render the page;  the number of logs generated when render this page;  the memory used to render the page (in Mo);\n* the number of database requests and the time spent to execute them.", 
            "title": "Ease debugging with Profiler"
        }, 
        {
            "location": "/developper-documentation/cookbooks/ease_debugging_with_profiler/#the-configuration-panel", 
            "text": "When you click on  BackBee CMS  version or application name, you access the  Configuration panel .  In this panel, informations from BackBee configuration are displayed:  Project configuration  In this section, the version of BackBee CMS used, the application name and the environment are displayed.  PHP configuration  In this section, the version of PHP used is displayed and informations about cache extensions.\nAlso, click on \"phpinfo\" will give you full informations about your PHP configuration.  Actives Bundle  In this section are listed all activated bundles (i.e exactly the same results as bundles registered in  bundles.yml  file).", 
            "title": "The Configuration panel"
        }, 
        {
            "location": "/developper-documentation/cookbooks/ease_debugging_with_profiler/#the-request-panel", 
            "text": "When you click on status code or in the action used to render page, you open the  Request panel .  In this panel, all informations from server and from Symfony Request object are displayed to help you understand the\ninformations used to render your page.  All the informations from PHP super globals related to the Request are displayed.   GET  and  POST  parameters;  Request attributes from BackBee:  _action : the action used to render the page;  _controller : the controller called to render the page;  _route : the route matched by the uri;  uri : if not controller was found, return \" root \" which means the BackBee  FrontController  is used.    Request cookies;  Request headers (also availables in debug toolbar from any web browser)  Request content  Request Server parameters:  Response headers;   But also, the  Session  informations and the  flashes  messages", 
            "title": "The Request panel"
        }, 
        {
            "location": "/developper-documentation/cookbooks/ease_debugging_with_profiler/#the-routing-panel", 
            "text": "When you click on \"Routing\", you open the  Request panel .  In addition to the  debug:routing  command available in  DebugBundle , the Routing panel provides a global overview of actual routes\nregistered in the application.  Routes are ordered by name, schema and patterns. For each route, the panel list the Controller/action couple called when the route is accessed.   This is a good way to discover the REST API.", 
            "title": "The Routing panel"
        }, 
        {
            "location": "/developper-documentation/cookbooks/ease_debugging_with_profiler/#the-database-panel", 
            "text": "When you click on the database icon or in the database informations, you open the  Database panel .  Queries section  This panel list all Doctrine requests used to render the page with the spending time and the runnable query.\nThis is useful when you want to optimize SQL queries or want to understand why you have a Doctrine error with a  QueryBuilder .  Doctrine ORM mapping section  If you create your own entities and want to use Doctrine 2 to save in database, you need set up theses PHP classes.\nThis section display all actual classes managed by Doctrine 2 and if the mapping is correctly set up,\nelse an explicit message is displayed to help you fix the mapping.", 
            "title": "The Database panel"
        }, 
        {
            "location": "/developper-documentation/cookbooks/use_swift_mailer_in_backbee/", 
            "text": "CookBooks\n\n\nUse Swiftmailer in BackBee\n\n\nIntroduction\n\n\nIn BackBee there is no home made component for mailing. We actually use Swift Mailer library.\nBackBee only provides a way to configure it and get your instance initialized easily.\n\n\nConfiguration\n\n\nTo configure Swift Mailer in BackBee you need to create mailer.yml into your global configuration folder \nrepository/Config\n.\n\n\nThe minimal configuration file is composed of an SMTP and  a port\n\n\nsmtp: localhost\nport: 25\n\n\n\n\nYou can also set up more parameters for more security on SMTP.\n\n\nsmtp: localhost\nport: 587\nusername: mailer_user_identifier\npassword: superSecretPassword\n\n\n\n\nBasic usage example\n\n\nTo retrieve the configured mailer you need an access to your Application.\nYou can start with a new app, but for performances matters prefer use the current Application.\nThe example will be placed in the context of an EventListener. \nThis is not a good practice to place your business logic into an EventListener\n but it is easier to understand.\n\n\n?php\nnamespace BackBee\\Bundle\\DocumentationBundle\\Listener;\n\nuse BackBee\\Event\\Event;\nuse BackBee\\Site\\Site;\n\nclass MailerListener\n{\n    public static function onSomethingNeedToBeMailed(Event $event)\n    {\n        // retrieve your current Application\n        $application = $event-\ngetDispatcher()-\ngetApplication();\n\n        // retrieve other informations\n        $site = $application-\ngetSite();\n\n        if ($site instanceof Site) {\n            // render e-mail body by using partial method from the renderer\n            $body = $application-\ngetRenderer()-\npartial(\n                'Email/Email.twig',\n                [\n                    'site_name' =\n $site-\ngetLabel(),\n                    'home_link' =\n $site-\ngetServerName(),\n                ]\n            );\n\n            // Build the message\n            $message = static::buildMessage(\n                $body,\n                $application-\ngetSite(),\n            );\n\n            // now get the configured mailer by passing by application and send your message\n            $application-\ngetMailer()-\nsend($message);\n        }\n    }\n\n    /**\n     * E-mail message creation\n     */\n    public static function buildMessage($body, $site)\n    {\n        $from = 'administrator@' . $site-\ngetServerName();\n\n        // Create Swift_Message\n        $message = \\Swift_Message::newInstance();\n        // Set the From address\n        $message-\naddFrom($from, $site-\ngetLabel());\n        // Set the To addresses\n        $message-\naddTo($from, $site-\ngetLabel());\n        // Give the message a subject\n        $message-\nsetSubject('Something append on ' . $site-\ngetLabel());\n        // Give it the body\n        $message-\nsetBody($body, 'text/html', 'UTF-8');\n\n        return $message;\n    }\n}\n\n\n\n\nIf you want do more with Swift Mailer, you can find additional documentation on \nSwift Mailer web site", 
            "title": "Use Swift Mailer in BackBee"
        }, 
        {
            "location": "/developper-documentation/cookbooks/use_swift_mailer_in_backbee/#cookbooks", 
            "text": "", 
            "title": "CookBooks"
        }, 
        {
            "location": "/developper-documentation/cookbooks/use_swift_mailer_in_backbee/#use-swiftmailer-in-backbee", 
            "text": "Introduction  In BackBee there is no home made component for mailing. We actually use Swift Mailer library.\nBackBee only provides a way to configure it and get your instance initialized easily.", 
            "title": "Use Swiftmailer in BackBee"
        }, 
        {
            "location": "/developper-documentation/cookbooks/use_swift_mailer_in_backbee/#configuration", 
            "text": "To configure Swift Mailer in BackBee you need to create mailer.yml into your global configuration folder  repository/Config .  The minimal configuration file is composed of an SMTP and  a port  smtp: localhost\nport: 25  You can also set up more parameters for more security on SMTP.  smtp: localhost\nport: 587\nusername: mailer_user_identifier\npassword: superSecretPassword  Basic usage example  To retrieve the configured mailer you need an access to your Application.\nYou can start with a new app, but for performances matters prefer use the current Application.\nThe example will be placed in the context of an EventListener.  This is not a good practice to place your business logic into an EventListener  but it is easier to understand.  ?php\nnamespace BackBee\\Bundle\\DocumentationBundle\\Listener;\n\nuse BackBee\\Event\\Event;\nuse BackBee\\Site\\Site;\n\nclass MailerListener\n{\n    public static function onSomethingNeedToBeMailed(Event $event)\n    {\n        // retrieve your current Application\n        $application = $event- getDispatcher()- getApplication();\n\n        // retrieve other informations\n        $site = $application- getSite();\n\n        if ($site instanceof Site) {\n            // render e-mail body by using partial method from the renderer\n            $body = $application- getRenderer()- partial(\n                'Email/Email.twig',\n                [\n                    'site_name' =  $site- getLabel(),\n                    'home_link' =  $site- getServerName(),\n                ]\n            );\n\n            // Build the message\n            $message = static::buildMessage(\n                $body,\n                $application- getSite(),\n            );\n\n            // now get the configured mailer by passing by application and send your message\n            $application- getMailer()- send($message);\n        }\n    }\n\n    /**\n     * E-mail message creation\n     */\n    public static function buildMessage($body, $site)\n    {\n        $from = 'administrator@' . $site- getServerName();\n\n        // Create Swift_Message\n        $message = \\Swift_Message::newInstance();\n        // Set the From address\n        $message- addFrom($from, $site- getLabel());\n        // Set the To addresses\n        $message- addTo($from, $site- getLabel());\n        // Give the message a subject\n        $message- setSubject('Something append on ' . $site- getLabel());\n        // Give it the body\n        $message- setBody($body, 'text/html', 'UTF-8');\n\n        return $message;\n    }\n}  If you want do more with Swift Mailer, you can find additional documentation on  Swift Mailer web site", 
            "title": "Configuration"
        }, 
        {
            "location": "/developper-documentation/components/classcontent/", 
            "text": "Component\n\n\nClassContent Component\n\n\nWhat is it a ClassContent?\n\n\nClassContents are at the heart of BackBee, every piece of content you will find in BackBee is a ClassContent. It defines your site and how you contribute to.\nClassContents can be extended, listened, versioned and they all have in common that they implement \nBackBee\\Renderer\\RenderableInterface\n.\nIn general a ClassContent is defined in YAML, it can be implemented in PHP too but the YAML notation because it's easier, quicker and scalable compared to PHP.\n\n\nHow it works\n\n\nThe definition of a ClassContent follows \nPHPCR recommendations\n and every flexible content is a combination of primary content types.\n\n\nPHPCR definition:\n\n\n\n\nThe PHP Content Repository is an adaption of the Java Content Repository (JCR) standard, an open API specification defined in JSR-283.\nThe API defines how to handle hierarchical semi-structured data in a consistent way.\n\n\nThe typical use case is content management systems. PHPCR combines the best out of document-oriented databases (weak structured data) and of XML databases (hierarchical trees). On top of that, it adds useful features like searching, versioning, access control and locking on top of it.\n\n\n\n\nA ClassContent is compose of it's definition class and it's templates. The storage of a ClassContent is automated and it's done int the content table, BackBee uses the Doctrine discriminator system to store contributed entities.\n\n\nA ClassContent definition is generally declared in an YAML file and is composed of three major parts \nproperties\n, \nelements\n and \nparameters\n\n\nNaming Convention\n\n\nA ClassContent is declared in a \nClassContent\n folder and it final namespace depends of the folder where you declare an new entity. All ClassContent have common root namespaces and is \nBackBee\\ClassContent\n. If you create a definition file into a folder named \nArticle\n and this file is named \nParagraph.yml\n the complete namespace to this content is\nBackBee\\ClassContent\\Article\\Paragraph\n.\n\n\nRespect the PSR naming convention. PSR specification is:\n\n\n\n\nNamespaces and classes MUST follow an \"autoloading\" PSR: [\nPSR-0\n, \nPSR-4\n].\nThis means each class is in a file by itself, and is in a namespace of at least one level: a top-level vendor name.\nClass names MUST be declared in StudlyCaps.\n\n\n\n\nEven if ClassContent are in most of the cases YML files, they are designed to become PHP Class, then you must declare names in StudlyCaps.\n\n\nPrimary ClassContent types\n\n\nThe primary ClassContents types are the most basic type you can find in BackBee. They are the base of every other Content.\n\n\nBackBee provides 5 primary ClassContent types:\n\n\n\n\nContentSet: a container of content, they are iterable and countable.\n\n\nElement\\Text: a simple text input\n\n\nElement\\File : an attached file\n\n\nElement\\Link : a URL link\n\n\nElement\\Keyword : a keyword association\n\n\n\n\nNative ClassContent types\n\n\nIn addition of the primary types BackBee provides four Natives ClassContents and this contents are an  extensions of primary contents:\n\n\n\n\nElement\\Attachment , an attachment content, extending Element\\File\n\n\nElement\\Date, a date input, extending Element\\Text\n\n\nElement\\Image , an image content, extending Element\\File\n\n\nElement\\Select , a select input, extending Element\\Text\n\n\n\n\nCreate a ClassContent definition\n\n\nIn most cases extending native and primary ClassContent is unnecessary. You simply create a new ClassContent type that uses some primary and native types.\n\n\nExample for an article :\n\n\nOur article will have one title, one picture and one body. You translate this textual definition in ClassContent as followed:\n\n\n\n\nArticle.yml\n\n\n\n\nArticle:\n  properties:\n    name: Article\n    description: \nAn is compose of one title, one picture and one body\n\n    category: [article]\n  elements:\n    title:\n      type: BackBee\\ClassContent\\Element\\Text\n      label: Title\n      default:\n        value: Your title here...\n      maxentry: 1\n    body:\n      type: BackBee\\ClassContent\\Element\\Text\n      label: Body\n      default:\n        value: Your abstract here...\n      maxentry: 1\n    picture:\n      type: BackBee\\ClassContent\\Element\\Image\n\n\n\n\nFocus on properties section:\n\n\nname: Article\n\n\n\n\nThe property \nname\n is for humans can be compose of multiple words like \"Basic Article\"\n\n\ndescription: \nAn is compose of one title, one picture and one body\n\n\n\n\n\nThe property \ndescription\n goes against human reading and provides a description of what to do with your ClassContent and/or what it  is compose of.\n\n\ncategory: [article]\n\n\n\n\nThe property \ncategory\n helps you to categorize your ClassContent and if a content isn't categorized it can't be edited online, youmusn't don't forget to assign a category to each of your content. In addition a ClassContent can be categorized and visually hidden in the toolbar if you use this notation:\n\n\ncategory: [!article]\n\n\n\n\nFocus on elements section:\n\n\ntitle:\n  type: BackBee\\ClassContent\\Element\\Text\n  label: Title\n  default:\n    value: Your title here...\n  maxentry: 1\n\n\n\n\ntitle:\n\n\n\n\nThis will be the identifier to your property and the way you access code like this  \n{{ this.render(title)|raw }}\n in template file\n\n\ntype: BackBee\\ClassContent\\Element\\Text\n\n\n\n\nType is the definition of your content. Here the title is defined by the primary ClassContent type \nElement\\Text\n\n\nlabel: Title\n\n\n\n\nThe property label is for humans and can be composed of multiple words like \"Basic Article\" it appears under a contribution form.\n\n\ndefault:\n  value: \nYour title here...\n\n\n\n\n\nThe default section allows you to define how appear just initialized ClassContent. Here the default value of the title is \"Your title here...\"\n\n\nmaxentry: 1\n\n\n\n\nMax entry determine how many can have as \ntitle\n in the article content.\n\n\nClassContent templates\n\n\nWhen BackBee tries to render your class content, it searches a template corresponding to it's name. In the previous case the searched template was \nArticle.twig\n or \nArticle.phtml\n\n\nIf BackBee can't find the template it will retrieve the template of each element and render the elements separately. If you provide only a definition, BackBee is able to render it.\n\n\n\n\nArticle.twig\n\n\n\n\narticle {{ this.bbcontent(null, null, {class: 'article box-wrapper'})|raw }} itemscope itemtype=\nhttp://schema.org/Article\n\n  \nh1 {{ this.bbcontent(title)|raw }} itemprop=\nheadline\n\n    {{ title.value|raw }}\n  \n/h1\n\n  \ndiv itemtype=\nhttp://schema.org/ImageObject\n itemprop=\nprimaryImageOfPage\n\n    {{ this.render(image, null, {'class': 'figure block-fullwidth'})|raw }}\n  \n/div\n\n  {{ this.render(body)|raw }}\n\n/article\n\n\n\n\n\ntemplate and render mode\n\n\nThe render mode has the same function as a template but it can be considered as an alternative template. In general render mode is automatically called by a block extending \nContentSet\n, by default when you render it use the name of this block to require an alternative rendering. But you can also define the rendering using \nparameters\n or in the template directly when you use the function render \nthis.render(Article, 'renderMode')\n.\n\n\nIn the next example we will put our article into an ArticleList and then we alternate the rendering of the article creating a file named \nArticle.ArticleList.twig\n and this template will automatically used by BackBee.\n\n\n\n\nArticle.ArticleList.twig\n\n\n\n\narticle {{ this.bbcontent(null, null, {class: 'article box-wrapper'})|raw }} itemscope itemtype=\nhttp://schema.org/Article\n\n  \nh2 {{ this.bbcontent(title)|raw }} itemprop=\nheadline\n\n    {{ title.value|raw }}\n  \n/h2\n\n  \ndiv itemtype=\nhttp://schema.org/ImageObject\n itemprop=\nprimaryImageOfPage\n\n    {{ this.render(image, null, {'class': 'figure block-fullwidth'})|raw }}\n  \n/div\n\n\n/article\n\n\n\n\n\nBackBee can't find the render mode \nArticle.ArticleList.twig\n it will try to render \nArticle.twig\n and it if doesn't find this template it will render each element with it's default rendering mode.\n\n\nContentSet\n\n\nContentSets are particular ClassContents instead of a classic ClassContent, a ContentSet doesn't have elements section and represents only an collection of other ClassContent. But you can customize a ClassContents trough his \nparameters\n section.\n\n\nRelatedContainer:\n  extends: \\BackBee\\ClassContent\\ContentSet\n  properties:\n    name: Linked article container\n    description: \nA block that display linked article\n\n    category: [Article]\n  parameters:\n    rendermode: related\n    accept: [BackBee\\ClassContent\\Article\\Article]\n\n\n\n\n\n\nhas you can see a ContentSet has extended \n\\BackBee\\ClassContent\\ContentSet\n\n\n\n\nFocus on parameters section:\n\n\nrendermode: related\n\n\n\n\nRender mode allow you to override the default behavior of BackBee by redefining the render mode named on sub content. We see before that by default BackBee tries to find a render mode by using the name of the ContentSet then by default \nRenderer\n search an file named \nArticle.RelatedContainer.twig\n. By using the \nrendermode\n setting you will find \nArticle.related.twig\n file.\n\n\naccept: [BackBee\\ClassContent\\Article\\Article]\n\n\n\n\nThe accept parameter prefilters the type of ClassContent you can add into your ContentSet.\n\n\nContentSet templates\n\n\nContentSet template exactly at same way as other ClassContent. The only difference is on you have to use a loop to render the collection.\n\n\n\n\nRelatedContainer.twig\n\n\n\n\n\ndiv {{ this.bbcontent(null, {'class': 'col-md-4'})|raw }}\n\n    {% for article in this.getObject().getData() %}\n        {{ this.render(article)|raw }}\n    {% endfor %}\n\n/div\n\n\n\n\n\nTo access to the ContentSet collection you have to use this way \nthis.getObject().getData()\n\n\nThe \"Autoblock\"\n\n\nAn Autoblock isn't a primitive or native ClassContent and is a mix between these two types.\nAn Autoblock is an fully automated Content, His collection isn't contributable and automatically creates list of ClassContent. This list is generated by the configuration of the Autoblock.\n\n\nBy default BackBee doesn't provide \"Autoblock\" but there is one provided into the standard edition.\n\n\nAn Autoblock has to be highly configurable and all of the configuration are created into the \nparameters\n section. An Autoblock has to implement a listener to automatically generate it collection. You can find more information into the Parameters section.\n\n\nOverride, Extends, listen and add Trait to your ClassContent\n\n\nOverriding a ClassContent\n\n\nAs with the Configuration system, you can override a ClassContent definition.\n\n\nThe priority system tries to find the definition and template in this order :\n- \nrepository/{context}/ClassContent\n into your current context\n- \nrepository/ClassContent\n into your default context\n- \n{bundle}/ClassContent\n into your bundles ClassContent folder\n- \nClassContent\n into ClassContent BackBee component\n\n\nIf you create a file with the same name as a existing content but in a different folder has priority, this content will modified and take the value in the created file. This work also for the template, but have to be replaced \nClassContent\n folder with \nTemplates/scripts\n\n\nExtends a ClassContent\n\n\nTo extend an other ClassContent, you just have to use \nextends\n keyword like in the example of the ContentSet.\n\n\nThere is lots of advantages to extending an other class content. First you do not have to rewrite properties and elements. The second advantage concerns rendering and listeners, BackBee will run through the parent classes to find templates and listener.\n\n\nListen a ClassContent\n\n\nAdd an event listener on a class content is pretty easy and you will find more information in the \nEvent Listener component\n.\n\n\nTo summarize each ClassContent have 5 events attach:\n- prerender\n- onrender\n- postrender\n- preflush\n- onflush\n\n\nAdd a Trait  to a ClassContent\n\n\nTrait lets go add behaviors to a ClassContent. By default BackBee doesn't provide trait, but like Autoblocks, some traits are available in the standard edition. Trait have exactly the same usage than the php Trait.\n\n\nClassContent Parameters\n\n\nParameters allow you to configure contents. ClassContent parameters are usually used in the listener but can be used everywhere. ClassContent parameters are contributed in back office by the user with the gearing button of Block.\n\n\nParameters are built from the block's YAML like\n\n\nBlockDemo:\n    properties:\n        name: Block demo\n        description: \nBlock for demonstration purposes\n\n        category: [Demo]\n    elements:\n        text:\n            type: BackBee\\ClassContent\\Element\\Text\n    parameters:\n        mytext:\n            label: 'My text'\n            type: 'text'\n            value: ''\n        myselect:\n            label: 'My select'\n            type: 'select'\n            options:\n                'foo': 'Foo'\n                'bar': 'Bar'\n            value: ['foo']\n\n\n\n\n\nUse parameters\n\n\nIf ClassContent Parameters are not validated by user the content parameters are overriden by revision parameters.\n\nOnly the value of the parameter is saved.\n\n\nTo get default parameters:\n\n\n?php\n$params = $content-\ngetDefaultParams();\n\n/** That returns all parameters with definitions and default values:\n *  array (size=2)\n *    'mytext' =\n\n *      array (size=3)\n *        'label' =\n string 'My text' (length=7)\n *        'type' =\n string 'text' (length=4)\n *        'value' =\n string '' (length=0)\n *    'myselect' =\n\n *      array (size=4)\n *        'label' =\n string 'My select' (length=9)\n *        'type' =\n string 'select' (length=6)\n *        'options' =\n\n *          array (size=2)\n *            'foo' =\n string 'Foo' (length=3)\n *            'bar' =\n string 'Bar' (length=3)string 'yolo' (length=4)\n *        'value' =\n\n *          array (size=1)\n *            0 =\n string 'foo' (length=3)\n */\n\n\n\n\nTo get all parameters:\n\n\n?php\n\n$params = $content-\ngetAllParams();\n\n/** That returns all parameters with definitions and new values\n *  array (size=2)\n *    'mytext' =\n\n *      array (size=3)\n *        'label' =\n string 'My text' (length=7)\n *        'type' =\n string 'text' (length=4)\n *        'value' =\n string '' (length=0)\n *    'myselect' =\n\n *      array (size=4)\n *        'label' =\n string 'My select' (length=9)\n *        'type' =\n string 'select' (length=6)\n *        'options' =\n\n *          array (size=2)\n *            'foo' =\n string 'Foo' (length=3)\n *            'bar' =\n string 'Bar' (length=3)\n *        'value' =\n\n *          array (size=1)\n *            0 =\n string 'foo' (length=3)\n */\n\n\n\n\nTo get one parameter:\n\n\n?php\n$param = $content-\ngetParam('mytext');\n\n/** That returns the definition and new value\n *  array (size=3)\n *    'label' =\n string 'My text' (length=7)\n *    'type' =\n string 'text' (length=4)\n *    'value' =\n string '' (length=0)\n */\n\n\n\n\nTo get the value of the parameter:\n\n\n?php\n$paramValue = $content-\ngetParamValue('mytext');\n\n// That returns the new value string '' (length=0)\n\n\n\n\nTo set a value, you need to set up the same type you declare in the YAML file as value:\n\n\n?php\n$content-\nsetParam('mytext', 'foo');\n$param = $content-\ngetParamValue('mytext')\n\n// That returns a new value set  string 'foo' (length=3)\n\n\n\n\nParameters reference\n\n\n\n\ncheckbox\n\n\ndatetimepicker\n\n\nhidden\n\n\nlinkSelector\n\n\nmediaSelector\n\n\nnodeSelector\n\n\npassword\n\n\nradio\n\n\nselect\n\n\ntext\n\n\ntextarea\n\n\n\n\nAll parameters have default options:\n\n\nDefault options\n\n\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\nDefault\n\n\nMandatory\n\n\n\n\n\n\n\n\n\n\nlabel\n\n\nString\n\n\nLabel is displayed above the field\n\n\nEmpty\n\n\nNo\n\n\n\n\n\n\nvalue\n\n\nMixed\n\n\nThis field must be set and allows to describe the  parameter's type\n\n\nNone\n\n\nYes\n\n\n\n\n\n\ntype\n\n\nString\n\n\nKey of one of available parameters\n\n\nNone\n\n\nYes\n\n\n\n\n\n\n\n\n\n\nCheckbox\n\n\nLike HTML checkbox attribute\n\n\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\nDefault\n\n\nMandatory\n\n\n\n\n\n\n\n\n\n\noptions\n\n\nArray\n\n\nList of options (key/value)\n\n\nEmpty array\n\n\nYes\n\n\n\n\n\n\ninline\n\n\nBoolean\n\n\nDisplay checkbox inline\n\n\nfalse\n\n\nNo\n\n\n\n\n\n\nvalue\n\n\nArray\n\n\nList of selected checkboxes\n\n\nEmpty array\n\n\nYes\n\n\n\n\n\n\n\n\nExample\n:\n\n\nparameters:\n    mycheckbox:\n        type: 'checkbox'\n        options:\n            'foo': 'Foo'\n            'bar': 'Bar'\n        value: ['foo']\n        inline: true\n\n\n\n\n?php\n$param = $content-\ngetParamValue('mycheckbox'); // sarray('foo')\n\n\n\n\n\n\nDatetime picker\n\n\nText element with a datetimepicker\n\n\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\nDefault\n\n\nMandatory\n\n\n\n\n\n\n\n\n\n\nvalue\n\n\nNumber\n\n\nIt is an timestamp value\n\n\nEmpty\n\n\nYes\n\n\n\n\n\n\n\n\nExample\n:\n\n\nparameters:\n    mydatetimepicker:\n        type: 'datetimepicker'\n        value: 1435573740\n\n\n\n\n?php\n$param = $content-\ngetParamValue('mydatetimepicker'); // 1435573740\n\n\n\n\n\n\nHidden\n\n\nLike HTML hidden attribute\n\n\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\nDefault\n\n\nMandatory\n\n\n\n\n\n\n\n\n\n\nvalue\n\n\nString\n\n\nThe default text\n\n\nEmpty\n\n\nYes\n\n\n\n\n\n\n\n\nExample\n:\n\n\nparameters:\n    myhidden:\n        type: 'hidden'\n        value: 'foo'\n\n\n\n\n?php\n$param = $content-\ngetParamValue('myhidden'); // foo\n\n\n\n\n\n\nLink selector\n\n\nLink selector allows you to choose a link from one of your website pages or an external link.\n\n\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\nDefault\n\n\nMandatory\n\n\n\n\n\n\n\n\n\n\nvalue\n\n\nJson\n\n\nObject which contains url / title / pageUid / target\n\n\nEmpty array\n\n\nYes\n\n\n\n\n\n\n\n\nExample\n:\n\n\nparameters:\n    mylinkselector:\n        type: 'linkSelector'\n        value: []\n\n\n\n\n?php\n# Example with select one link\n$param = $content-\ngetParamValue('mylinkselector');\n// array('url' =\n '/foo', 'title' =\n 'Foo', 'pageUid' =\n 'anPageUid', 'target' =\n '_self')\n\n\n\n\n Page tree \n:\nWe recommend to retrieve the url from the page entity instead of the url attribute because the url can change.\n\n\n External link \n :\nIn this case, note the pageUid attribute is (obviously) null.\n\n\n\n\nMedia selector\n\n\nMedia selector allows you to choose a list of media in the media library.\n\n\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\nDefault\n\n\nMandatory\n\n\n\n\n\n\n\n\n\n\nvalue\n\n\nJson\n\n\nObject which contains folder_uid / image / media_id / title /type / uid\n\n\nEmpty array\n\n\nYes\n\n\n\n\n\n\n\n\nExample\n:\n\n\nparameters:\n    mymediaselector:\n        type: 'mediaSelector'\n        value: []\n\n\n\n\n?php\n# Example with select one media\n$param = $content-\ngetParamValue('mymediaselector');\n// array(array('folder_uid' =\n 'anFolderUid', 'image' =\n 'imageUrl', 'media_id' =\n '1', 'title' =\n '_Foo', 'type' =\n 'Media/Image', 'uid' =\n 'anUid'))\n\n\n\n\n\n\nNode selector\n\n\nNode selector allows you to choose a page from tree\n\n\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\nDefault\n\n\nMandatory\n\n\n\n\n\n\n\n\n\n\nvalue\n\n\nJson\n\n\nObject which contains url  pageUid / title\n\n\nEmpty array\n\n\nYes\n\n\n\n\n\n\n\n\nExample\n:\n\n\nparameters:\n    mynodeselector:\n        type: 'nodeSelector'\n        value: []\n\n\n\n\n# Example of node selection\n$param = $content-\ngetParamValue('mynodeselector');\n# array('pageUid' =\n 'anPageUid', 'title' =\n 'Foo')\n\n\n\n\nWe recommend retrieving the title from the page entity instead of the attributed title because the title can change.\n\n\n\n\nPassword\n\n\nLike HTML password attribute\n\n\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\nDefault\n\n\nMandatory\n\n\n\n\n\n\n\n\n\n\nvalue\n\n\nString\n\n\nThe default text\n\n\nEmpty\n\n\nYes\n\n\n\n\n\n\n\n\nExample\n:\n\n\nparameters:\n    mypassword:\n        type: 'password'\n        value: 'foo'\n\n\n\n\n?php\n$param = $content-\ngetParamValue('mypassword'); // foo\n\n\n\n\n\n\nRadio\n\n\nLike HTML radio attribute\n\n\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\nDefault\n\n\nMandatory\n\n\n\n\n\n\n\n\n\n\noptions\n\n\nArray\n\n\nList of options (key/value)\n\n\nEmpty array\n\n\nYes\n\n\n\n\n\n\ninline\n\n\nBoolean\n\n\nDisplay radio inline\n\n\nfalse\n\n\nNo\n\n\n\n\n\n\nvalue\n\n\nArray\n\n\nList of selected radio\n\n\nEmpty array\n\n\nYes\n\n\n\n\n\n\n\n\nExample\n:\n\n\nparameters:\n    myradio:\n        type: 'radio'\n        options:\n            'foo': 'Foo'\n            'bar': 'Bar'\n        value: ['foo']\n        inline: true\n\n\n\n\n?php\n$param = $content-\ngetParamValue('myradio'); // array('foo')\n\n\n\n\n\n\nSelect\n\n\nLike HTML select attribute\n\n\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\nDefault\n\n\nMandatory\n\n\n\n\n\n\n\n\n\n\noptions\n\n\nArray\n\n\nList of options (key/value)\n\n\nEmpty array\n\n\nYes\n\n\n\n\n\n\nvalue\n\n\nArray\n\n\nList of selected radio\n\n\nEmpty array\n\n\nYes\n\n\n\n\n\n\nmultiple\n\n\nBoolean\n\n\nAllows multiple selection\n\n\nfalse\n\n\nNo\n\n\n\n\n\n\n\n\nExample\n:\n\n\nparameters:\n    mypassword:\n        type: 'select'\n        options:\n            'foo': 'Foo'\n            'bar': 'Bar'\n        value: ['foo']\n        multiple: true\n\n\n\n\n?php\n$param = $content-\ngetParamValue('myradio'); //array('foo')\n\n\n\n\n\n\nText\n\n\nLike HTML text attribute\n\n\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\nDefault\n\n\nMandatory\n\n\n\n\n\n\n\n\n\n\nvalue\n\n\nString\n\n\nThe default text\n\n\nEmpty\n\n\nYes\n\n\n\n\n\n\n\n\nExample\n:\n\n\nparameters:\n    mytext:\n        type: 'text'\n        value: 'foo'\n\n\n\n\n?php\n$param = $content-\ngetParamValue('mypassword'); // foo\n\n\n\n\n\n\nTextarea\n\n\nLike HTML textearea attribute\n\n\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\nDefault\n\n\nMandatory\n\n\n\n\n\n\n\n\n\n\nvalue\n\n\nString\n\n\nThe default text\n\n\nEmpty\n\n\nYes\n\n\n\n\n\n\nrows\n\n\nString\n\n\nthe rows html attribute\n\n\n5\n\n\nNo\n\n\n\n\n\n\n\n\nExample\n:\n\n\nparameters:\n    mytextearea:\n        type: 'textarea'\n        value: 'BackBee'\n        rows: 10\n\n\n\n\n?php\n$param = $content-\ngetParamValue('mytextearea'); // BackBee\n\n\n\n\n\n\nSpecial parameters\n\n\nRendermode\n\n\nRendermode parameters automatically list rendermodes of content and use them directly.\n\n\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\nDefault\n\n\nMandatory\n\n\n\n\n\n\n\n\n\n\nvalue\n\n\nArray\n\n\nSelected rendermode\n\n\nEmpty\n\n\nYes\n\n\n\n\n\n\n\n\nparameters:\n    rendermode:\n        type: 'select'\n        value: []\n\n\n\n\nThe key must be 'rendermode'", 
            "title": "ClassContent"
        }, 
        {
            "location": "/developper-documentation/components/classcontent/#component", 
            "text": "", 
            "title": "Component"
        }, 
        {
            "location": "/developper-documentation/components/classcontent/#classcontent-component", 
            "text": "What is it a ClassContent?  ClassContents are at the heart of BackBee, every piece of content you will find in BackBee is a ClassContent. It defines your site and how you contribute to.\nClassContents can be extended, listened, versioned and they all have in common that they implement  BackBee\\Renderer\\RenderableInterface .\nIn general a ClassContent is defined in YAML, it can be implemented in PHP too but the YAML notation because it's easier, quicker and scalable compared to PHP.  How it works  The definition of a ClassContent follows  PHPCR recommendations  and every flexible content is a combination of primary content types.  PHPCR definition:   The PHP Content Repository is an adaption of the Java Content Repository (JCR) standard, an open API specification defined in JSR-283.\nThe API defines how to handle hierarchical semi-structured data in a consistent way.  The typical use case is content management systems. PHPCR combines the best out of document-oriented databases (weak structured data) and of XML databases (hierarchical trees). On top of that, it adds useful features like searching, versioning, access control and locking on top of it.   A ClassContent is compose of it's definition class and it's templates. The storage of a ClassContent is automated and it's done int the content table, BackBee uses the Doctrine discriminator system to store contributed entities.  A ClassContent definition is generally declared in an YAML file and is composed of three major parts  properties ,  elements  and  parameters  Naming Convention  A ClassContent is declared in a  ClassContent  folder and it final namespace depends of the folder where you declare an new entity. All ClassContent have common root namespaces and is  BackBee\\ClassContent . If you create a definition file into a folder named  Article  and this file is named  Paragraph.yml  the complete namespace to this content is BackBee\\ClassContent\\Article\\Paragraph .  Respect the PSR naming convention. PSR specification is:   Namespaces and classes MUST follow an \"autoloading\" PSR: [ PSR-0 ,  PSR-4 ].\nThis means each class is in a file by itself, and is in a namespace of at least one level: a top-level vendor name.\nClass names MUST be declared in StudlyCaps.   Even if ClassContent are in most of the cases YML files, they are designed to become PHP Class, then you must declare names in StudlyCaps.  Primary ClassContent types  The primary ClassContents types are the most basic type you can find in BackBee. They are the base of every other Content.  BackBee provides 5 primary ClassContent types:   ContentSet: a container of content, they are iterable and countable.  Element\\Text: a simple text input  Element\\File : an attached file  Element\\Link : a URL link  Element\\Keyword : a keyword association   Native ClassContent types  In addition of the primary types BackBee provides four Natives ClassContents and this contents are an  extensions of primary contents:   Element\\Attachment , an attachment content, extending Element\\File  Element\\Date, a date input, extending Element\\Text  Element\\Image , an image content, extending Element\\File  Element\\Select , a select input, extending Element\\Text   Create a ClassContent definition  In most cases extending native and primary ClassContent is unnecessary. You simply create a new ClassContent type that uses some primary and native types.  Example for an article :  Our article will have one title, one picture and one body. You translate this textual definition in ClassContent as followed:   Article.yml   Article:\n  properties:\n    name: Article\n    description:  An is compose of one title, one picture and one body \n    category: [article]\n  elements:\n    title:\n      type: BackBee\\ClassContent\\Element\\Text\n      label: Title\n      default:\n        value: Your title here...\n      maxentry: 1\n    body:\n      type: BackBee\\ClassContent\\Element\\Text\n      label: Body\n      default:\n        value: Your abstract here...\n      maxentry: 1\n    picture:\n      type: BackBee\\ClassContent\\Element\\Image  Focus on properties section:  name: Article  The property  name  is for humans can be compose of multiple words like \"Basic Article\"  description:  An is compose of one title, one picture and one body   The property  description  goes against human reading and provides a description of what to do with your ClassContent and/or what it  is compose of.  category: [article]  The property  category  helps you to categorize your ClassContent and if a content isn't categorized it can't be edited online, youmusn't don't forget to assign a category to each of your content. In addition a ClassContent can be categorized and visually hidden in the toolbar if you use this notation:  category: [!article]  Focus on elements section:  title:\n  type: BackBee\\ClassContent\\Element\\Text\n  label: Title\n  default:\n    value: Your title here...\n  maxentry: 1  title:  This will be the identifier to your property and the way you access code like this   {{ this.render(title)|raw }}  in template file  type: BackBee\\ClassContent\\Element\\Text  Type is the definition of your content. Here the title is defined by the primary ClassContent type  Element\\Text  label: Title  The property label is for humans and can be composed of multiple words like \"Basic Article\" it appears under a contribution form.  default:\n  value:  Your title here...   The default section allows you to define how appear just initialized ClassContent. Here the default value of the title is \"Your title here...\"  maxentry: 1  Max entry determine how many can have as  title  in the article content.  ClassContent templates  When BackBee tries to render your class content, it searches a template corresponding to it's name. In the previous case the searched template was  Article.twig  or  Article.phtml  If BackBee can't find the template it will retrieve the template of each element and render the elements separately. If you provide only a definition, BackBee is able to render it.   Article.twig   article {{ this.bbcontent(null, null, {class: 'article box-wrapper'})|raw }} itemscope itemtype= http://schema.org/Article \n   h1 {{ this.bbcontent(title)|raw }} itemprop= headline \n    {{ title.value|raw }}\n   /h1 \n   div itemtype= http://schema.org/ImageObject  itemprop= primaryImageOfPage \n    {{ this.render(image, null, {'class': 'figure block-fullwidth'})|raw }}\n   /div \n  {{ this.render(body)|raw }} /article   template and render mode  The render mode has the same function as a template but it can be considered as an alternative template. In general render mode is automatically called by a block extending  ContentSet , by default when you render it use the name of this block to require an alternative rendering. But you can also define the rendering using  parameters  or in the template directly when you use the function render  this.render(Article, 'renderMode') .  In the next example we will put our article into an ArticleList and then we alternate the rendering of the article creating a file named  Article.ArticleList.twig  and this template will automatically used by BackBee.   Article.ArticleList.twig   article {{ this.bbcontent(null, null, {class: 'article box-wrapper'})|raw }} itemscope itemtype= http://schema.org/Article \n   h2 {{ this.bbcontent(title)|raw }} itemprop= headline \n    {{ title.value|raw }}\n   /h2 \n   div itemtype= http://schema.org/ImageObject  itemprop= primaryImageOfPage \n    {{ this.render(image, null, {'class': 'figure block-fullwidth'})|raw }}\n   /div  /article   BackBee can't find the render mode  Article.ArticleList.twig  it will try to render  Article.twig  and it if doesn't find this template it will render each element with it's default rendering mode.  ContentSet  ContentSets are particular ClassContents instead of a classic ClassContent, a ContentSet doesn't have elements section and represents only an collection of other ClassContent. But you can customize a ClassContents trough his  parameters  section.  RelatedContainer:\n  extends: \\BackBee\\ClassContent\\ContentSet\n  properties:\n    name: Linked article container\n    description:  A block that display linked article \n    category: [Article]\n  parameters:\n    rendermode: related\n    accept: [BackBee\\ClassContent\\Article\\Article]   has you can see a ContentSet has extended  \\BackBee\\ClassContent\\ContentSet   Focus on parameters section:  rendermode: related  Render mode allow you to override the default behavior of BackBee by redefining the render mode named on sub content. We see before that by default BackBee tries to find a render mode by using the name of the ContentSet then by default  Renderer  search an file named  Article.RelatedContainer.twig . By using the  rendermode  setting you will find  Article.related.twig  file.  accept: [BackBee\\ClassContent\\Article\\Article]  The accept parameter prefilters the type of ClassContent you can add into your ContentSet.  ContentSet templates  ContentSet template exactly at same way as other ClassContent. The only difference is on you have to use a loop to render the collection.   RelatedContainer.twig   div {{ this.bbcontent(null, {'class': 'col-md-4'})|raw }} \n    {% for article in this.getObject().getData() %}\n        {{ this.render(article)|raw }}\n    {% endfor %} /div   To access to the ContentSet collection you have to use this way  this.getObject().getData()  The \"Autoblock\"  An Autoblock isn't a primitive or native ClassContent and is a mix between these two types.\nAn Autoblock is an fully automated Content, His collection isn't contributable and automatically creates list of ClassContent. This list is generated by the configuration of the Autoblock.  By default BackBee doesn't provide \"Autoblock\" but there is one provided into the standard edition.  An Autoblock has to be highly configurable and all of the configuration are created into the  parameters  section. An Autoblock has to implement a listener to automatically generate it collection. You can find more information into the Parameters section.  Override, Extends, listen and add Trait to your ClassContent  Overriding a ClassContent  As with the Configuration system, you can override a ClassContent definition.  The priority system tries to find the definition and template in this order :\n-  repository/{context}/ClassContent  into your current context\n-  repository/ClassContent  into your default context\n-  {bundle}/ClassContent  into your bundles ClassContent folder\n-  ClassContent  into ClassContent BackBee component  If you create a file with the same name as a existing content but in a different folder has priority, this content will modified and take the value in the created file. This work also for the template, but have to be replaced  ClassContent  folder with  Templates/scripts  Extends a ClassContent  To extend an other ClassContent, you just have to use  extends  keyword like in the example of the ContentSet.  There is lots of advantages to extending an other class content. First you do not have to rewrite properties and elements. The second advantage concerns rendering and listeners, BackBee will run through the parent classes to find templates and listener.  Listen a ClassContent  Add an event listener on a class content is pretty easy and you will find more information in the  Event Listener component .  To summarize each ClassContent have 5 events attach:\n- prerender\n- onrender\n- postrender\n- preflush\n- onflush  Add a Trait  to a ClassContent  Trait lets go add behaviors to a ClassContent. By default BackBee doesn't provide trait, but like Autoblocks, some traits are available in the standard edition. Trait have exactly the same usage than the php Trait.  ClassContent Parameters  Parameters allow you to configure contents. ClassContent parameters are usually used in the listener but can be used everywhere. ClassContent parameters are contributed in back office by the user with the gearing button of Block.  Parameters are built from the block's YAML like  BlockDemo:\n    properties:\n        name: Block demo\n        description:  Block for demonstration purposes \n        category: [Demo]\n    elements:\n        text:\n            type: BackBee\\ClassContent\\Element\\Text\n    parameters:\n        mytext:\n            label: 'My text'\n            type: 'text'\n            value: ''\n        myselect:\n            label: 'My select'\n            type: 'select'\n            options:\n                'foo': 'Foo'\n                'bar': 'Bar'\n            value: ['foo']  Use parameters  If ClassContent Parameters are not validated by user the content parameters are overriden by revision parameters. Only the value of the parameter is saved.  To get default parameters:  ?php\n$params = $content- getDefaultParams();\n\n/** That returns all parameters with definitions and default values:\n *  array (size=2)\n *    'mytext' = \n *      array (size=3)\n *        'label' =  string 'My text' (length=7)\n *        'type' =  string 'text' (length=4)\n *        'value' =  string '' (length=0)\n *    'myselect' = \n *      array (size=4)\n *        'label' =  string 'My select' (length=9)\n *        'type' =  string 'select' (length=6)\n *        'options' = \n *          array (size=2)\n *            'foo' =  string 'Foo' (length=3)\n *            'bar' =  string 'Bar' (length=3)string 'yolo' (length=4)\n *        'value' = \n *          array (size=1)\n *            0 =  string 'foo' (length=3)\n */  To get all parameters:  ?php\n\n$params = $content- getAllParams();\n\n/** That returns all parameters with definitions and new values\n *  array (size=2)\n *    'mytext' = \n *      array (size=3)\n *        'label' =  string 'My text' (length=7)\n *        'type' =  string 'text' (length=4)\n *        'value' =  string '' (length=0)\n *    'myselect' = \n *      array (size=4)\n *        'label' =  string 'My select' (length=9)\n *        'type' =  string 'select' (length=6)\n *        'options' = \n *          array (size=2)\n *            'foo' =  string 'Foo' (length=3)\n *            'bar' =  string 'Bar' (length=3)\n *        'value' = \n *          array (size=1)\n *            0 =  string 'foo' (length=3)\n */  To get one parameter:  ?php\n$param = $content- getParam('mytext');\n\n/** That returns the definition and new value\n *  array (size=3)\n *    'label' =  string 'My text' (length=7)\n *    'type' =  string 'text' (length=4)\n *    'value' =  string '' (length=0)\n */  To get the value of the parameter:  ?php\n$paramValue = $content- getParamValue('mytext');\n\n// That returns the new value string '' (length=0)  To set a value, you need to set up the same type you declare in the YAML file as value:  ?php\n$content- setParam('mytext', 'foo');\n$param = $content- getParamValue('mytext')\n\n// That returns a new value set  string 'foo' (length=3)  Parameters reference   checkbox  datetimepicker  hidden  linkSelector  mediaSelector  nodeSelector  password  radio  select  text  textarea   All parameters have default options:  Default options      Type  Description  Default  Mandatory      label  String  Label is displayed above the field  Empty  No    value  Mixed  This field must be set and allows to describe the  parameter's type  None  Yes    type  String  Key of one of available parameters  None  Yes      Checkbox  Like HTML checkbox attribute      Type  Description  Default  Mandatory      options  Array  List of options (key/value)  Empty array  Yes    inline  Boolean  Display checkbox inline  false  No    value  Array  List of selected checkboxes  Empty array  Yes     Example :  parameters:\n    mycheckbox:\n        type: 'checkbox'\n        options:\n            'foo': 'Foo'\n            'bar': 'Bar'\n        value: ['foo']\n        inline: true  ?php\n$param = $content- getParamValue('mycheckbox'); // sarray('foo')   Datetime picker  Text element with a datetimepicker      Type  Description  Default  Mandatory      value  Number  It is an timestamp value  Empty  Yes     Example :  parameters:\n    mydatetimepicker:\n        type: 'datetimepicker'\n        value: 1435573740  ?php\n$param = $content- getParamValue('mydatetimepicker'); // 1435573740   Hidden  Like HTML hidden attribute      Type  Description  Default  Mandatory      value  String  The default text  Empty  Yes     Example :  parameters:\n    myhidden:\n        type: 'hidden'\n        value: 'foo'  ?php\n$param = $content- getParamValue('myhidden'); // foo   Link selector  Link selector allows you to choose a link from one of your website pages or an external link.      Type  Description  Default  Mandatory      value  Json  Object which contains url / title / pageUid / target  Empty array  Yes     Example :  parameters:\n    mylinkselector:\n        type: 'linkSelector'\n        value: []  ?php\n# Example with select one link\n$param = $content- getParamValue('mylinkselector');\n// array('url' =  '/foo', 'title' =  'Foo', 'pageUid' =  'anPageUid', 'target' =  '_self')   Page tree  :\nWe recommend to retrieve the url from the page entity instead of the url attribute because the url can change.   External link   :\nIn this case, note the pageUid attribute is (obviously) null.   Media selector  Media selector allows you to choose a list of media in the media library.      Type  Description  Default  Mandatory      value  Json  Object which contains folder_uid / image / media_id / title /type / uid  Empty array  Yes     Example :  parameters:\n    mymediaselector:\n        type: 'mediaSelector'\n        value: []  ?php\n# Example with select one media\n$param = $content- getParamValue('mymediaselector');\n// array(array('folder_uid' =  'anFolderUid', 'image' =  'imageUrl', 'media_id' =  '1', 'title' =  '_Foo', 'type' =  'Media/Image', 'uid' =  'anUid'))   Node selector  Node selector allows you to choose a page from tree      Type  Description  Default  Mandatory      value  Json  Object which contains url  pageUid / title  Empty array  Yes     Example :  parameters:\n    mynodeselector:\n        type: 'nodeSelector'\n        value: []  # Example of node selection\n$param = $content- getParamValue('mynodeselector');\n# array('pageUid' =  'anPageUid', 'title' =  'Foo')  We recommend retrieving the title from the page entity instead of the attributed title because the title can change.   Password  Like HTML password attribute      Type  Description  Default  Mandatory      value  String  The default text  Empty  Yes     Example :  parameters:\n    mypassword:\n        type: 'password'\n        value: 'foo'  ?php\n$param = $content- getParamValue('mypassword'); // foo   Radio  Like HTML radio attribute      Type  Description  Default  Mandatory      options  Array  List of options (key/value)  Empty array  Yes    inline  Boolean  Display radio inline  false  No    value  Array  List of selected radio  Empty array  Yes     Example :  parameters:\n    myradio:\n        type: 'radio'\n        options:\n            'foo': 'Foo'\n            'bar': 'Bar'\n        value: ['foo']\n        inline: true  ?php\n$param = $content- getParamValue('myradio'); // array('foo')   Select  Like HTML select attribute      Type  Description  Default  Mandatory      options  Array  List of options (key/value)  Empty array  Yes    value  Array  List of selected radio  Empty array  Yes    multiple  Boolean  Allows multiple selection  false  No     Example :  parameters:\n    mypassword:\n        type: 'select'\n        options:\n            'foo': 'Foo'\n            'bar': 'Bar'\n        value: ['foo']\n        multiple: true  ?php\n$param = $content- getParamValue('myradio'); //array('foo')   Text  Like HTML text attribute      Type  Description  Default  Mandatory      value  String  The default text  Empty  Yes     Example :  parameters:\n    mytext:\n        type: 'text'\n        value: 'foo'  ?php\n$param = $content- getParamValue('mypassword'); // foo   Textarea  Like HTML textearea attribute      Type  Description  Default  Mandatory      value  String  The default text  Empty  Yes    rows  String  the rows html attribute  5  No     Example :  parameters:\n    mytextearea:\n        type: 'textarea'\n        value: 'BackBee'\n        rows: 10  ?php\n$param = $content- getParamValue('mytextearea'); // BackBee   Special parameters  Rendermode  Rendermode parameters automatically list rendermodes of content and use them directly.      Type  Description  Default  Mandatory      value  Array  Selected rendermode  Empty  Yes     parameters:\n    rendermode:\n        type: 'select'\n        value: []  The key must be 'rendermode'", 
            "title": "ClassContent Component"
        }, 
        {
            "location": "/developper-documentation/components/config/", 
            "text": "Components\n\n\nThe Config component\n\n\nThis component is used in BackBee to set parameters from YAML files into the Container.\n\n\nHow the Config component work ?\n\n\nThe BackBee Config Component provides a \nConfig\n object able to:\n\n\n\n\nParse YAML files from a directory;\n\n\nPersist this configuration in file or in database;\n\n\nSet this configuration in \nBackBee Container\n;\n\n\nSave and load configuration from \nBackBee Cache\n;\n\n\n\n\n?php\n\nuse BackBee\\Cache\\AbstractCache;\nuse BackBee\\Config\\Config;\nuse BackBee\\DependencyInjection\\Container;\nuse BackBee\\DependencyInjection\\DispatchTagEventInterface;\nuse BackBee\\DependencyInjection\\Dumper\\DumpableServiceInterface;\n\nclass Config implements DispatchTagEventInterface, DumpableServiceInterface\n{\n    public function __construct(\n        $basedir,\n        AbstractCache $cache = null,\n        Container $container = null,\n        $debug = false,\n        array $yml_to_ignore = []\n    ){/*..*/}\n}\n\n?\n\n\n\n\n\nThis component is not related and not compatible with Symfony Config component.\n\n\nYAML parsing, filtering and extending\n\n\nThe BackBee Config Component can take a valid directory as argument, and merge the configuration according to the data set\nin this YAML files. If you don't know YAML, you can take a look to the \nSymfony YAML format documentation\n.\n\n\nMoreover, BackBee Config component allows you to ignore some files.\n\n\n?php\n\nuse BackBee\\Config\\Config;\n\nclass Foo\n{\n    const DIRECTORY = '/my-valid/path';\n\n    public function returnConfiguration(array $filesToIgnore)\n    {\n        return new Config(self::DIRECTORY, null, null, false, $filesToIgnore);\n    }\n}\n\n?\n\n\n\n\n\nThis way, the ignored files won't be parsed.\n\n\nThanks to the \nBackBee environments\n, you can also extend and improve your default configuration.\nFor instance, let's say you want to add a specific configuration when your are in a \"testing\" environment.\n\n\nYou can set the environment this way:\n\n\n?php\n\nuse BackBee\\Config\\Config;\n\nclass Foo\n{\n    const DIRECTORY = '/my-valid/path';\n\n    public function TestingConfiguration()\n    {\n        $config = new Config('/repository/Config', null, null, false, []);\n\n        return $config-\nsetEnvironment('testing');\n\n        /**\n         * Now the object is able to parse YAML files from theses directories:\n         * /repository/Config\n         * /repository/Config/testing\n         * and we are also able to parse specific \nenvironment files\n:\n         * /repository/Config/foo.testing.yml\n         */\n    }\n}\n\n?\n\n\n\n\n\nThis is simple and powerful, you can be very specific on the configuration you want to use.\nConfigurations keys and parameters are merged recursively, starting from base directory to the environnement directory.\nThank to the \"On cascade system\", you can also add a new directory to allow an override of the current configuration.\n\n\n?php\n\nuse BackBee\\Config\\Config;\n\nclass Foo\n{\n    const DIRECTORY = '/my-valid/path';\n\n    public function overrideTestingConfiguration(Config $config, $directory)\n    {\n        return $config-\nextend($directory);\n\n        /**\n         * Now the object is able to parse YAML files from theses directories:\n         * /repository/Config/\n$directory\n\n         * If a key is declared in \n$directory\n configuration files, the configuration is overriden\n         */\n    }\n}\n\n?\n\n\n\n\n\nConfiguration persisting\n\n\nThe BackBee Config Component can persist configurations in file or in database, you can also create your own \"persistors\"\nthanks to the \nBackBee\\Config\\PersistorInterface\n.\n\n\nFor now, two persistors are provided in BackBee CMS:\n\n\n\n\nthe \nFile\n Persistor allows you to write and override the main configuration file (config.yml)\n\n\nthe \nRegistry\n Persistor is a simple database Key/Value system\n\n\n\n\nIf we take a look at the BackBee CMS configuration:\n\n\nconfig:\n    save_in_registry: true # default value: true\n    persistor: [BackBee\\Config\\Persistor\\File, BackBee\\Config\\Persistor\\Registry]\n\n\n\n\n\n\nsave_in_registry\n is a particular option: if true, this means BackBee will try to look for an overidden configuration\n  stored in Registry.\n\n\npersistor\n is the list of activated persistors. BackBee will loop on each and try to find configuration. If no one\n  provides the requested configuration, an exception will be thrown.\n\n\n\n\nConfiguration caching\n\n\nThe BackBee Config Component is fully compatible with BackBee Cache component.\n\n\nWhen you create your Config object, you can pass an instance of \nBackBee\\Cache\\AbstractCache\n as a second argument.\nThis way, in non-debug mode (fourth argument, \nfalse\n by default), the second time you get the information, the configuration\nwill be constructed from cache instead of built again from files or database registry.", 
            "title": "Config"
        }, 
        {
            "location": "/developper-documentation/components/config/#components", 
            "text": "", 
            "title": "Components"
        }, 
        {
            "location": "/developper-documentation/components/config/#the-config-component", 
            "text": "This component is used in BackBee to set parameters from YAML files into the Container.", 
            "title": "The Config component"
        }, 
        {
            "location": "/developper-documentation/components/config/#how-the-config-component-work", 
            "text": "The BackBee Config Component provides a  Config  object able to:   Parse YAML files from a directory;  Persist this configuration in file or in database;  Set this configuration in  BackBee Container ;  Save and load configuration from  BackBee Cache ;   ?php\n\nuse BackBee\\Cache\\AbstractCache;\nuse BackBee\\Config\\Config;\nuse BackBee\\DependencyInjection\\Container;\nuse BackBee\\DependencyInjection\\DispatchTagEventInterface;\nuse BackBee\\DependencyInjection\\Dumper\\DumpableServiceInterface;\n\nclass Config implements DispatchTagEventInterface, DumpableServiceInterface\n{\n    public function __construct(\n        $basedir,\n        AbstractCache $cache = null,\n        Container $container = null,\n        $debug = false,\n        array $yml_to_ignore = []\n    ){/*..*/}\n}\n\n?   This component is not related and not compatible with Symfony Config component.", 
            "title": "How the Config component work ?"
        }, 
        {
            "location": "/developper-documentation/components/config/#yaml-parsing-filtering-and-extending", 
            "text": "The BackBee Config Component can take a valid directory as argument, and merge the configuration according to the data set\nin this YAML files. If you don't know YAML, you can take a look to the  Symfony YAML format documentation .  Moreover, BackBee Config component allows you to ignore some files.  ?php\n\nuse BackBee\\Config\\Config;\n\nclass Foo\n{\n    const DIRECTORY = '/my-valid/path';\n\n    public function returnConfiguration(array $filesToIgnore)\n    {\n        return new Config(self::DIRECTORY, null, null, false, $filesToIgnore);\n    }\n}\n\n?   This way, the ignored files won't be parsed.  Thanks to the  BackBee environments , you can also extend and improve your default configuration.\nFor instance, let's say you want to add a specific configuration when your are in a \"testing\" environment.  You can set the environment this way:  ?php\n\nuse BackBee\\Config\\Config;\n\nclass Foo\n{\n    const DIRECTORY = '/my-valid/path';\n\n    public function TestingConfiguration()\n    {\n        $config = new Config('/repository/Config', null, null, false, []);\n\n        return $config- setEnvironment('testing');\n\n        /**\n         * Now the object is able to parse YAML files from theses directories:\n         * /repository/Config\n         * /repository/Config/testing\n         * and we are also able to parse specific  environment files :\n         * /repository/Config/foo.testing.yml\n         */\n    }\n}\n\n?   This is simple and powerful, you can be very specific on the configuration you want to use.\nConfigurations keys and parameters are merged recursively, starting from base directory to the environnement directory.\nThank to the \"On cascade system\", you can also add a new directory to allow an override of the current configuration.  ?php\n\nuse BackBee\\Config\\Config;\n\nclass Foo\n{\n    const DIRECTORY = '/my-valid/path';\n\n    public function overrideTestingConfiguration(Config $config, $directory)\n    {\n        return $config- extend($directory);\n\n        /**\n         * Now the object is able to parse YAML files from theses directories:\n         * /repository/Config/ $directory \n         * If a key is declared in  $directory  configuration files, the configuration is overriden\n         */\n    }\n}\n\n?", 
            "title": "YAML parsing, filtering and extending"
        }, 
        {
            "location": "/developper-documentation/components/config/#configuration-persisting", 
            "text": "The BackBee Config Component can persist configurations in file or in database, you can also create your own \"persistors\"\nthanks to the  BackBee\\Config\\PersistorInterface .  For now, two persistors are provided in BackBee CMS:   the  File  Persistor allows you to write and override the main configuration file (config.yml)  the  Registry  Persistor is a simple database Key/Value system   If we take a look at the BackBee CMS configuration:  config:\n    save_in_registry: true # default value: true\n    persistor: [BackBee\\Config\\Persistor\\File, BackBee\\Config\\Persistor\\Registry]   save_in_registry  is a particular option: if true, this means BackBee will try to look for an overidden configuration\n  stored in Registry.  persistor  is the list of activated persistors. BackBee will loop on each and try to find configuration. If no one\n  provides the requested configuration, an exception will be thrown.", 
            "title": "Configuration persisting"
        }, 
        {
            "location": "/developper-documentation/components/config/#configuration-caching", 
            "text": "The BackBee Config Component is fully compatible with BackBee Cache component.  When you create your Config object, you can pass an instance of  BackBee\\Cache\\AbstractCache  as a second argument.\nThis way, in non-debug mode (fourth argument,  false  by default), the second time you get the information, the configuration\nwill be constructed from cache instead of built again from files or database registry.", 
            "title": "Configuration caching"
        }, 
        {
            "location": "/developper-documentation/components/event_listener/", 
            "text": "Components\n\n\nThe Event Listener component\n\n\nEvents\n are a common and effective way to tie together loosely coupled components in an application.\nAn event is generally used to broadcast a change that has occured during a process. If a \ncomponent\n is\ninterested in a particular event, it can \nlisten\n to it. When this particular event is triggered, a \nmethod\n,\noften called \ncallback\n or \nhandler\n is executed. Events are convenient ways to share\ndata between components.\nIn \nBackBee\n, events are triggered by an \nEventDispatcher\n and an \nEventListener\n is used to listen to them.\n\n\nEvent\n\n\nNamespace: BackBee\\Event\\Event\n\n\nThe Backbee event class extend \nsfEvent\n and allows us to create a generic \nEvent\n object.\nA generic event object has two properties: \ntarget\n and \nargs\n;\nThe target property represents the target of the event. The \nargs\n is an optional associated map.\nWhen the \nargs\n property is provided, it's sent to the listeners.\nCustom Event can be created by extending the class \nBackBee\\Event\\Event\n.\n\n\n?php\n$myHelloEvent = new Event($target, array(\nmessage\n=\nHello BackBee\n);\n\n\n\n\n\nEvent Listener\n\n\nNamespace: BackBee\\Event\\EventListener\n\n\nTo listen to an event you must use the \naddListener\n method of the \nEventDispatcher\n.\n\naddListener\n takes three parameters. The first one is the name of the event that will be triggered, the second is an array whose first element\nis a class path and the second is a method. The last parameter is the priority of the event. Listener with higher priority will be triggered first.\n\n\n$this-\napplication-\ngetEventDispatcher()-\naddListener(\"loading.event\", array(\"BackBee/Event/Listener/HelloListener\", \"sayHello\"));\n\n\n\nHere, we register the listener \nHelloListener\n to be executed when the event \nloading.event\n is occured.\n\n\n    \n?php\n\n        namespace BackBee\\Event\\Listener;\n        use BackBee\\Event\\Event;\n\n        class HelloListener {\n\n            public static sayHello (Event $event) {\n\n                $dispatcher = $event-\ngetDispatcher();\n\n                if ($event-\nhasArguments(\nmessage\n)) {\n                    $message = $event-\nget(\nmessage\n);\n                    if ( null !== $dispatcher-\ngetApplication()) {\n                        $dispatcher-\ngetApplication()-\ngetLogging()-\nnotice($message);\n                    }\n                }\n            }\n        }\n\n    ?\n\n\n\n\n\nNotice that the event object has access to the \napplication\n \nvia\n the \nEventDispacher\n and that the \nsayHello\n is a \nstatic\n method.\n\n\nEvent Dispatcher\n\n\nNamespace: BackBee\\Event\\EventListener\n\n\nEvents are \ndispatched\n or \ntriggered\n by the \nEventDispatcher\n by using the method \ntriggerEvent\n\nThe sample bellow shows how to listen to an event.\n\n\nTo trigger an event, we must use the \nEventDispatcher\n. It provides, among others, a \ndispatch\n method that takes two arguments. A name and an event object.\n\n\n?php\n    $this-\napplication-\ngetEventDispatcher()-\ndispatch(\nloading.event\n, $myHelloEvent);\n\n\n\n\nWhen the \nloading.event\n is dispatched by the \nEventDispatcher\n, all the registered listeners will be executed. In our example,\nthe static \nsayHello\n method of the \nBackbee/Event/Listener/HelloListener\n will be called.\n\n\nEvents from Class Content Component\n\n\nOne of the main purpose of \nBackbee\n is to render contents. As we have seen, a\ncontent is defined in a \n.yml\n file. Content creation and content rendering go\nthrough many phases that \nBackbee\n exposes with events. By instance, an event is triggered\nwhen a content is created, before and after a content has been saved, when the rendering process\nis started, while the content is been rendered, after the renderer process and so on. These events\nallow us the act in different ways on the contents lifecycle and rendering process itself.\n\n\nClassContent events are similar to custom events. But, as they take place when the main application\nis dealing with a request, a common way to listen to them is to use an \nevent.yml\n config file.\nWill try to local event file in the \nrepository/Config\n folder. Bellow is an example of how to\nuse the file.\n\n\n    article.article.render:\n        listeners:\n            - [BackBee\\Event\\Listener\\ArticleListener, onRender]\n\n    social.facebook.prerender:\n        listeners:\n            - [BackBee\\Event\\Listener\\Socialistener, PrerenderFacebook]\n\n\n\n\nevents.yml\n is a declarative way to add listeners to \nClassContentEvents\n event. Under the hook,\nthis yaml file is parsed and the \nEventDispatcher\n is used to register the listeners.\nIn our example,  \narticle.article.render\n and \nsocial.facebook.prerender\n are events names.\nBy convention \nBackBee\n transforms ClassContent class path to event name. Let's take a look at our events files.\n\n\nAccording to our \nevent.yml\n, the \narticle.article.render\n event will be triggered when\nthe content \nClassContent/Article/Article.yml\n is about the be rendered whereas\nthe 'social.facebook.prerender' will be triggered \nbefore\n the content \nClassContent/Social/Facebook.yml\n\nwas rendered.\n\n*.render\n  and \n*.prerender\n are events triggered by the \nRenderer\n object. Bellow is the list of\nall the Renderer events.\n\n\n\n\n*.prerender\n : is triggered \nbefore\n the content is being rendered;\n\n\n*.render\n : when the content is about to be rendered;\n\n\n*.postrender\n : after the render process.\n\n\n\n\nHowever there is no strong difference between \nrender\n and \npostrender\n.\n\n\nIn BackBee all the contents are \nDoctrine\n entities. These doctrine events are also available for all the contents.\n\n\n\n\npreremove\n\n\npostremove\n\n\npostupdate\n\n\npreupdate\n\n\nupdate\n\n\nprepersist\n\n\npostpersist\n\n\npostload\n\n\nonflush\n\n\n\n\nClassContent Listener\n\n\nTo listen to a ClassContentEvent we have to create a \nListener\n class. By default BackBee\nwill look for Listener in the repository/Config/Listener folder.\n\n\n    \n?php\n        namespace BackBee\\Event\\Listener,\n        use BackBee\\Event\\Event;\n\n        class ArticleListener extends Event {\n\n            public static function onRender(Event $event){\n                /* The renderer object */\n                $renderer = $event-\ngetEventArgs();\n\n                /* The eventDispatcher */\n                $eventDistacher = $event-\ngetDispatcher();\n\n                /* the BackBee application */\n                $application = $eventDistacher-\ngetApplication();\n\n                /* The article classcontent */\n                $content = $renderer-\ngetObject();\n\n                /* Add a new parameter that will be available in the content template */\n                $renderer-\nassign('myParams', \nmy Param value\n);\n            }\n        }\n    ?\n\n\n\n\n\nEvent inheritance\n\n\nIn \nBackBee\n content can be inherited from one another. The \nEventDispatcher\n respects this inheritance.\nIf an event is triggered for a subContent it will also be triggered for its parents. So \nclass content\n Events bubbles up in BackBee.", 
            "title": "Event Listener"
        }, 
        {
            "location": "/developper-documentation/components/event_listener/#components", 
            "text": "", 
            "title": "Components"
        }, 
        {
            "location": "/developper-documentation/components/event_listener/#the-event-listener-component", 
            "text": "Events  are a common and effective way to tie together loosely coupled components in an application.\nAn event is generally used to broadcast a change that has occured during a process. If a  component  is\ninterested in a particular event, it can  listen  to it. When this particular event is triggered, a  method ,\noften called  callback  or  handler  is executed. Events are convenient ways to share\ndata between components.\nIn  BackBee , events are triggered by an  EventDispatcher  and an  EventListener  is used to listen to them.", 
            "title": "The Event Listener component"
        }, 
        {
            "location": "/developper-documentation/components/event_listener/#event", 
            "text": "Namespace: BackBee\\Event\\Event  The Backbee event class extend  sfEvent  and allows us to create a generic  Event  object.\nA generic event object has two properties:  target  and  args ;\nThe target property represents the target of the event. The  args  is an optional associated map.\nWhen the  args  property is provided, it's sent to the listeners.\nCustom Event can be created by extending the class  BackBee\\Event\\Event .  ?php\n$myHelloEvent = new Event($target, array( message = Hello BackBee );", 
            "title": "Event"
        }, 
        {
            "location": "/developper-documentation/components/event_listener/#event-listener", 
            "text": "Namespace: BackBee\\Event\\EventListener  To listen to an event you must use the  addListener  method of the  EventDispatcher . addListener  takes three parameters. The first one is the name of the event that will be triggered, the second is an array whose first element\nis a class path and the second is a method. The last parameter is the priority of the event. Listener with higher priority will be triggered first.  $this- application- getEventDispatcher()- addListener(\"loading.event\", array(\"BackBee/Event/Listener/HelloListener\", \"sayHello\"));  Here, we register the listener  HelloListener  to be executed when the event  loading.event  is occured.       ?php\n\n        namespace BackBee\\Event\\Listener;\n        use BackBee\\Event\\Event;\n\n        class HelloListener {\n\n            public static sayHello (Event $event) {\n\n                $dispatcher = $event- getDispatcher();\n\n                if ($event- hasArguments( message )) {\n                    $message = $event- get( message );\n                    if ( null !== $dispatcher- getApplication()) {\n                        $dispatcher- getApplication()- getLogging()- notice($message);\n                    }\n                }\n            }\n        }\n\n    ?   Notice that the event object has access to the  application   via  the  EventDispacher  and that the  sayHello  is a  static  method.", 
            "title": "Event Listener"
        }, 
        {
            "location": "/developper-documentation/components/event_listener/#event-dispatcher", 
            "text": "Namespace: BackBee\\Event\\EventListener  Events are  dispatched  or  triggered  by the  EventDispatcher  by using the method  triggerEvent \nThe sample bellow shows how to listen to an event.  To trigger an event, we must use the  EventDispatcher . It provides, among others, a  dispatch  method that takes two arguments. A name and an event object.  ?php\n    $this- application- getEventDispatcher()- dispatch( loading.event , $myHelloEvent);  When the  loading.event  is dispatched by the  EventDispatcher , all the registered listeners will be executed. In our example,\nthe static  sayHello  method of the  Backbee/Event/Listener/HelloListener  will be called.", 
            "title": "Event Dispatcher"
        }, 
        {
            "location": "/developper-documentation/components/event_listener/#events-from-class-content-component", 
            "text": "One of the main purpose of  Backbee  is to render contents. As we have seen, a\ncontent is defined in a  .yml  file. Content creation and content rendering go\nthrough many phases that  Backbee  exposes with events. By instance, an event is triggered\nwhen a content is created, before and after a content has been saved, when the rendering process\nis started, while the content is been rendered, after the renderer process and so on. These events\nallow us the act in different ways on the contents lifecycle and rendering process itself.  ClassContent events are similar to custom events. But, as they take place when the main application\nis dealing with a request, a common way to listen to them is to use an  event.yml  config file.\nWill try to local event file in the  repository/Config  folder. Bellow is an example of how to\nuse the file.      article.article.render:\n        listeners:\n            - [BackBee\\Event\\Listener\\ArticleListener, onRender]\n\n    social.facebook.prerender:\n        listeners:\n            - [BackBee\\Event\\Listener\\Socialistener, PrerenderFacebook]  events.yml  is a declarative way to add listeners to  ClassContentEvents  event. Under the hook,\nthis yaml file is parsed and the  EventDispatcher  is used to register the listeners.\nIn our example,   article.article.render  and  social.facebook.prerender  are events names.\nBy convention  BackBee  transforms ClassContent class path to event name. Let's take a look at our events files.  According to our  event.yml , the  article.article.render  event will be triggered when\nthe content  ClassContent/Article/Article.yml  is about the be rendered whereas\nthe 'social.facebook.prerender' will be triggered  before  the content  ClassContent/Social/Facebook.yml \nwas rendered. *.render   and  *.prerender  are events triggered by the  Renderer  object. Bellow is the list of\nall the Renderer events.   *.prerender  : is triggered  before  the content is being rendered;  *.render  : when the content is about to be rendered;  *.postrender  : after the render process.   However there is no strong difference between  render  and  postrender .  In BackBee all the contents are  Doctrine  entities. These doctrine events are also available for all the contents.   preremove  postremove  postupdate  preupdate  update  prepersist  postpersist  postload  onflush", 
            "title": "Events from Class Content Component"
        }, 
        {
            "location": "/developper-documentation/components/event_listener/#classcontent-listener", 
            "text": "To listen to a ClassContentEvent we have to create a  Listener  class. By default BackBee\nwill look for Listener in the repository/Config/Listener folder.       ?php\n        namespace BackBee\\Event\\Listener,\n        use BackBee\\Event\\Event;\n\n        class ArticleListener extends Event {\n\n            public static function onRender(Event $event){\n                /* The renderer object */\n                $renderer = $event- getEventArgs();\n\n                /* The eventDispatcher */\n                $eventDistacher = $event- getDispatcher();\n\n                /* the BackBee application */\n                $application = $eventDistacher- getApplication();\n\n                /* The article classcontent */\n                $content = $renderer- getObject();\n\n                /* Add a new parameter that will be available in the content template */\n                $renderer- assign('myParams',  my Param value );\n            }\n        }\n    ?", 
            "title": "ClassContent Listener"
        }, 
        {
            "location": "/developper-documentation/components/event_listener/#event-inheritance", 
            "text": "In  BackBee  content can be inherited from one another. The  EventDispatcher  respects this inheritance.\nIf an event is triggered for a subContent it will also be triggered for its parents. So  class content  Events bubbles up in BackBee.", 
            "title": "Event inheritance"
        }, 
        {
            "location": "/developper-documentation/components/routing/", 
            "text": "Components\n\n\nThe Routing component\n\n\nThis component is used in BackBee to map an HTTP request to a set of configuration variables.\nNote this component is an extension of \nSymfony Routing Component\n, so the official documentation is\nstill valid.\n\n\nHow the Routing component work ?\n\n\nTo set a basic routing system, you need at least to set and configure three objects:\n\n\n\n\nA \nBackBee\\Routing\\RouteCollection\n instance, which contains routes definitions (instance of \nBackBee\\Routing\\Route\n);\n\n\nA \nBackBee\\Routing\\RequestContext\n instance, which embed the current request;\n\n\nFinaly, a \nRequestMatcher\n instance, in charge of performs the mapping from request to a Route.\n\n\n\n\nIn BackBee CMS, all routes are declared in \nBackBee/Config/route.yml\n file, but obviously you can create your own routes in Standard\nEdition if you have frameworks needs outside the \"CMS\" context (backend bundles for instance).\n\n\nThe \nroute.yml\n is parsed by the Yaml component and BackBee create a \nRouteCollection\n instance, which is stored in Container as the\n\nrouting\n service (Symfony developpers should notice this behavior is a little bit different to the Symfony \nrouter\n service which is not available in BackBee).\n\n\nIn this file, you can find all the routes (and so on, paths) from the actual REST API used to communicate with the Javascript client when you are logged to BackBee Standard Edition.\n\n\nAlso, some routes are defined to handle some resources and finaly the most important route is the default route.\n\n\nLet's take an example:\n\n\n# Access all media\nbb.media.list:\n  pattern: /rest/{version}/medialist\n  defaults:\n    _action: medialistAction\n    _controller: BackBee\\Rest\\Controller\\MediaController # can be a service definition\n  requirements:\n    _method: GET\n\n\n\n\nA \nBackBee\\Route\n is defined by a pattern (mostly an url path) where we can use variables, have some mandatory defaults\n(binded to a Controller and an action) and may have some requirements.\n\n\nRouting component requirements\n\n\nThe \nrequirements\n property allow use to add requirements used by the \nRequestMatcher\n to map an url to a request.\n\n\nThis is an example of some available requirements:\n\n\n# this route is very difficult to match\nroute.name:\n  pattern: /route/{a}/{b}/{c}/difficult\n  defaults:\n    _action: fooAction\n    _controller: Baz\\BarController\n  requirements:\n    a: .+ # accept regex conditions\n    b: \\d+\n    _method:POST\n    condition: \ncontext.getMethod() in ['GET', 'HEAD'] and request.headers.get('User-Agent') matches '/firefox/i'\n # use the Symfony Expression Language component\n\n\n\n\nThe \ncondition\n requirement can use the Symfony Expression Language component and have access to:\n\n \ncontext\n: the instance of RequestContext;\n\n \nrequest\n: the instance of the actual Request;\n\n\nIf you are interested in this component, you can take a look to the official \nExpression Language\n documentation.", 
            "title": "Routing"
        }, 
        {
            "location": "/developper-documentation/components/routing/#components", 
            "text": "", 
            "title": "Components"
        }, 
        {
            "location": "/developper-documentation/components/routing/#the-routing-component", 
            "text": "This component is used in BackBee to map an HTTP request to a set of configuration variables.\nNote this component is an extension of  Symfony Routing Component , so the official documentation is\nstill valid.", 
            "title": "The Routing component"
        }, 
        {
            "location": "/developper-documentation/components/routing/#how-the-routing-component-work", 
            "text": "To set a basic routing system, you need at least to set and configure three objects:   A  BackBee\\Routing\\RouteCollection  instance, which contains routes definitions (instance of  BackBee\\Routing\\Route );  A  BackBee\\Routing\\RequestContext  instance, which embed the current request;  Finaly, a  RequestMatcher  instance, in charge of performs the mapping from request to a Route.   In BackBee CMS, all routes are declared in  BackBee/Config/route.yml  file, but obviously you can create your own routes in Standard\nEdition if you have frameworks needs outside the \"CMS\" context (backend bundles for instance).  The  route.yml  is parsed by the Yaml component and BackBee create a  RouteCollection  instance, which is stored in Container as the routing  service (Symfony developpers should notice this behavior is a little bit different to the Symfony  router  service which is not available in BackBee).  In this file, you can find all the routes (and so on, paths) from the actual REST API used to communicate with the Javascript client when you are logged to BackBee Standard Edition.  Also, some routes are defined to handle some resources and finaly the most important route is the default route.  Let's take an example:  # Access all media\nbb.media.list:\n  pattern: /rest/{version}/medialist\n  defaults:\n    _action: medialistAction\n    _controller: BackBee\\Rest\\Controller\\MediaController # can be a service definition\n  requirements:\n    _method: GET  A  BackBee\\Route  is defined by a pattern (mostly an url path) where we can use variables, have some mandatory defaults\n(binded to a Controller and an action) and may have some requirements.", 
            "title": "How the Routing component work ?"
        }, 
        {
            "location": "/developper-documentation/components/routing/#routing-component-requirements", 
            "text": "The  requirements  property allow use to add requirements used by the  RequestMatcher  to map an url to a request.  This is an example of some available requirements:  # this route is very difficult to match\nroute.name:\n  pattern: /route/{a}/{b}/{c}/difficult\n  defaults:\n    _action: fooAction\n    _controller: Baz\\BarController\n  requirements:\n    a: .+ # accept regex conditions\n    b: \\d+\n    _method:POST\n    condition:  context.getMethod() in ['GET', 'HEAD'] and request.headers.get('User-Agent') matches '/firefox/i'  # use the Symfony Expression Language component  The  condition  requirement can use the Symfony Expression Language component and have access to:   context : the instance of RequestContext;   request : the instance of the actual Request;  If you are interested in this component, you can take a look to the official  Expression Language  documentation.", 
            "title": "Routing component requirements"
        }, 
        {
            "location": "/developper-documentation/components/security/", 
            "text": "Components\n\n\nThe Security component\n\n\nBackBee\n Security component is based on the Security Component of \nSymfony\n.\n\n\nIt provides a robust way to secure a web application. Here we will present some of the core concepts of this component : \nfirewall\n, \nFirewallMap\n, \nauthentication\n , \nauthorization\n, \nDecissionAccess\n,  \nVoter\n, \nSecurityContext\n.\n\n\nOverview of security mechanism\n\n\nThe main purpose of the security component is to deal with \nauthentication\n and \nauthorization\n.\n\n\nAuthentication is a way to grant access to a ressource. When a user is successfully authentified, authorization is a way to control access to a specific ressource.\n\n\nAuthentication is handled by what is called a \nfirewall\n. An application can have many secured areas, an admin area for instance.\n\n\nA secured area is determined by an \nurl\n. When an url that is part of a secured area is requested, behind the hook some registered callbacks are executed.\n\n\nThe \nFirewall\n archives this by listening to the \nsymfony\n \nkernel.request\n event triggered by the HttpKernel.\nA \nFirewallMap\n maps a \nrequest\n with the registered listeners then checks if the current request is under a secured area or is already secured.\n\n\nA \nFirewallMap\n Listener can authenticate a request, throws an \nAuthenticationException\n or do nothing. If one of these listeners throw an exception (meaning that the request is not authentificated), this exception can either be transformed into an \nAccessDeniedHttpException\n or used to initiate an authentication process by calling the \nFirewall\n entry point.\n\n\nAuthentication\n\n\nA firewall entry point, as it implements the \nauthenticationEntryPointInterface\n, must provided a \nstart\n method which takes two parameters: a request and the exception previously raised.\n\n\nstart\n must return a \nResponse\n object that can be a page showing a form for instance.\nIf one of the \nFirewallMap\n Listener can handle the request, it creates a \nToken\n object that holds a reference to the current user, its roles and its credentials.\nThe listener then uses an \nauthenticationProviderManager\n object to authenticate the \nToken\n. \nauthenticationProviderManager\n will authenticate the token if provided and return an \nauthenticated\n one if the user credential is valid.\n\n\nOtherwise an \nAuthenticationException\n is raised.\nEach \nToken\n uses a specific type of \nauthenticationProvider\n. An \nauthenticationProvider\n must implements the \nauthenticationProviderInterface\n and provides the two methods :  \nauthentificate\n which takes one paramater that must implements the \nTokenInterface\n and \nsupports\n which is used to check whether or not the given \ntoken\n is supported by the authentication provider .\n\n\nRegistered FirewallMap Listeners must implement the \nListenerInterface\n thus provided an \nhandle\n method that accept an \nGetRequestEvent\n object.\n\n\nAuthorization\n\n\nOnce a user is identified his roles or any other attributes or object of its \ntoken\n can be used to determine whether or not he has access to a resource.\n\n\nDecision manager\n\n\nAn \nAccessControlManager\n is used to make final access decisions based on \nVoter\n.\n\n\nA voter can decide to \nvote\n either for grant or deny access to a ressource. A voter can also abstain itself.\n\n\nBy default The \nAccessControllerManagers\n make his decision according to one these three strategies:\n\n\n\n\naffirmative\n (Access is granted if any voter votes for granting access)\n\n\nconsensus\n (Access is granted if there are more voters willing to granting access then otherwise\n\n\nunanimous\n (Access is granted if all voters vote for granting access)\n\n\n\n\nUnderstand voters\n\n\nA voter class must implements the \nVoterInterface\n which has 4 methods:\n\n\n\n\nsupportsAttribute($attribute)\n\n\nsupportsClass($class)\n\n\nvote(TokentInterface $token, $object, $attributes)\n\n\n\n\nsupportsAttribute\n is used to check if the voter supports some attributes of the token.\n\nsupportClass\n is user to check it the voter supports a specific class\n\nvote\n handle the vote strategy and must return of those class Constant :\n\n\n\n\nVoterInterface::ACCESS_GRANTED\n\n\nVoterInterface::ACCESS_ABSTAIN\n\n\nVoterInterface::ACCESS_DENIED\n\n\n\n\nBellow is list of Voter used in BackBee\n\n AccessVoter\n\n BBAclVoter\n\n BBRoleVoter\n\n SudoVoter\n\n\nBackBee SecurityContext and the ContextInterface\n\n\nAll the process of creating \nFirewall\n, \nFirewallMap\n, \nAuthenticationManager\n, \nAccessDecisionMananger\n and listeners is handled by the \nBackBee\\Security\\SecurityContext\n object.\n\n\nHowever the way of dealing with security Listerners is simplyfied by using a \nContext\n object.\nA security \nContext\n extends the abstract class \nBackBee\\Security\\Context\\BBAuthContext\n and defines the \nloadListeners\n method.\n\n\nLoadListeners\n accepts one parameter which is the security config that can be setted in \nrepository/Config/security.yml\n.\nA context can be used to instanciate new listener or to register new authentication provider to the \nSecuriryContext\n.\n\n\nBellow we show all the  security contexts provided by BackBee.\n\n\n\n\nAnonymousContext\n\n\nBBAuthContext\n\n\nLogoutContext\n\n\nRestfulContext\n\n\nStatelessContext\n\n\nUsernamePasswordContext\n\n\n\n\nAnonymousContext\n\n\nAnonymouseContext\n is used to identify anonymous user.\n\n\n\n\nauthentication provider\n : \nBackBee\\Security\\Authentication\\Provider\\AnonymousAuthenticationProvider\n\n\nListener\n: \nBackBee\\Security\\Listeners\\AnonymousAuthenticationListener\n\n\nToken\n : \nBackBee\\Security\\Token\\AnonymousToken\n\n\n\n\nBBAuthContext\n\n\nBBAuthContext\n is used to authentify a user by using the BackBee User table.\n\n\n\n\nauthentication provider\n : \nBackBee\\Security\\Authentication\\Provider\\BBAuthenticationProvider\n\n\nListener\n: \nBackBee\\Security\\Listeners\\AnonymousAuthenticationListener\n\n\nToken\n : \nBackBee\\Security\\Token\\BBUserToken\n\n\n\n\nLogoutContext\n\n\nLogoutContext\n handles user logout by removing all setted tokens.\n\n\n\n\nauthentication provider\n : \nnone\n\n\nToken\n : \nnone\n\n\nListener\n: \nBackBee\\Security\\Listeners\\LogoutListener\n\n\n\n\nRestfulContext\n\n\nRestfulContext\n is used to authentify rest user with a plublic key.\n\n\n\n\nauthentication provider\n: \nBackBee\\Security\\Listeners\\PublicKeyAuthenticationProvider\n\n\nListener\n : \nBackBee\\Security\\Listeners\\PublicKeyAuthenticationListener\n\n\nToken\n: \nBackBee\\Security\\Token\\BBUserToken\n\n\n\n\nStatelessContext\n\n\nIn stateless mode, authentication is asked for every requests. \nStatelessContext\n handles sessions\ncreation every time stateless mode is disabled.\n\n\n\n\nauthentication provider\n: \nnone\n\n\nListener\n: \nBackBee\\Security\\Listeners\\ContextListener\n\n\nToken\n: \nnone\n\n\n\n\nUsernamePasswordContext\n\n\nUsernamePasswordContext\nis used to authenticate user by using a login form.\n\n\n\n\nauthentication provider\n: \nBackBee\\Security\\Listeners\\Provider\\UserAuthenticationProvider\n\n\nListener\n: \nBackBee\\Security\\Listeners\\UsernamePasswordAuthenticationListener\n\n\nToken\n: \nBackBee\\Security\\Token\\UsernamePasswordToken\n\n\n\n\nConfiguring Security with \nsecurity.yml\n\n\nSecurity configurations can be handled with a simple yml file. This file can be found in \nrepository/Config/security.yml\n.\n\n\nfirewalls:\n    bb_area:\n        pattern: ^/\n        requirements:\n            HTTP-X-Requested-With: XMLHttpRequest\n            HTTP-X-BB-METHOD: (JsonRpc|Upload)\n        provider: bb_user\n        bb_auth:\n            provider: bb_user\n            nonce_dir: security/nonces\n            lifetime: 1800\n            use_registry: true\n\nproviders:\n    bb_user:\n        entity:\n            class: BackBee\\Security\\User\n        secret: %secret_key%\n    public_key:\n        entity:\n            class: BackBee\\Security\\User\n\ncontexts:\n    BackBee\\Security\\Context: [StatelessContext, AnonymousContext, BBAuthContext, UsernamePasswordContext, LogoutContext, RestfulContext]\n\nencoders:\n    BackBee\\Security\\User:\n        class: Symfony\\Component\\Security\\Core\\Encoder\\MessageDigestPasswordEncoder\n        arguments:\n            algorithm: md5\n            encode_as_base64: false\n            iterations: 1\n\nacl:\n    connection: default", 
            "title": "Security"
        }, 
        {
            "location": "/developper-documentation/components/security/#components", 
            "text": "", 
            "title": "Components"
        }, 
        {
            "location": "/developper-documentation/components/security/#the-security-component", 
            "text": "BackBee  Security component is based on the Security Component of  Symfony .  It provides a robust way to secure a web application. Here we will present some of the core concepts of this component :  firewall ,  FirewallMap ,  authentication  ,  authorization ,  DecissionAccess ,   Voter ,  SecurityContext .", 
            "title": "The Security component"
        }, 
        {
            "location": "/developper-documentation/components/security/#overview-of-security-mechanism", 
            "text": "The main purpose of the security component is to deal with  authentication  and  authorization .  Authentication is a way to grant access to a ressource. When a user is successfully authentified, authorization is a way to control access to a specific ressource.  Authentication is handled by what is called a  firewall . An application can have many secured areas, an admin area for instance.  A secured area is determined by an  url . When an url that is part of a secured area is requested, behind the hook some registered callbacks are executed.  The  Firewall  archives this by listening to the  symfony   kernel.request  event triggered by the HttpKernel.\nA  FirewallMap  maps a  request  with the registered listeners then checks if the current request is under a secured area or is already secured.  A  FirewallMap  Listener can authenticate a request, throws an  AuthenticationException  or do nothing. If one of these listeners throw an exception (meaning that the request is not authentificated), this exception can either be transformed into an  AccessDeniedHttpException  or used to initiate an authentication process by calling the  Firewall  entry point.", 
            "title": "Overview of security mechanism"
        }, 
        {
            "location": "/developper-documentation/components/security/#authentication", 
            "text": "A firewall entry point, as it implements the  authenticationEntryPointInterface , must provided a  start  method which takes two parameters: a request and the exception previously raised.  start  must return a  Response  object that can be a page showing a form for instance.\nIf one of the  FirewallMap  Listener can handle the request, it creates a  Token  object that holds a reference to the current user, its roles and its credentials.\nThe listener then uses an  authenticationProviderManager  object to authenticate the  Token .  authenticationProviderManager  will authenticate the token if provided and return an  authenticated  one if the user credential is valid.  Otherwise an  AuthenticationException  is raised.\nEach  Token  uses a specific type of  authenticationProvider . An  authenticationProvider  must implements the  authenticationProviderInterface  and provides the two methods :   authentificate  which takes one paramater that must implements the  TokenInterface  and  supports  which is used to check whether or not the given  token  is supported by the authentication provider .  Registered FirewallMap Listeners must implement the  ListenerInterface  thus provided an  handle  method that accept an  GetRequestEvent  object.", 
            "title": "Authentication"
        }, 
        {
            "location": "/developper-documentation/components/security/#authorization", 
            "text": "Once a user is identified his roles or any other attributes or object of its  token  can be used to determine whether or not he has access to a resource.  Decision manager  An  AccessControlManager  is used to make final access decisions based on  Voter .  A voter can decide to  vote  either for grant or deny access to a ressource. A voter can also abstain itself.  By default The  AccessControllerManagers  make his decision according to one these three strategies:   affirmative  (Access is granted if any voter votes for granting access)  consensus  (Access is granted if there are more voters willing to granting access then otherwise  unanimous  (Access is granted if all voters vote for granting access)   Understand voters  A voter class must implements the  VoterInterface  which has 4 methods:   supportsAttribute($attribute)  supportsClass($class)  vote(TokentInterface $token, $object, $attributes)   supportsAttribute  is used to check if the voter supports some attributes of the token. supportClass  is user to check it the voter supports a specific class vote  handle the vote strategy and must return of those class Constant :   VoterInterface::ACCESS_GRANTED  VoterInterface::ACCESS_ABSTAIN  VoterInterface::ACCESS_DENIED   Bellow is list of Voter used in BackBee  AccessVoter  BBAclVoter  BBRoleVoter  SudoVoter", 
            "title": "Authorization"
        }, 
        {
            "location": "/developper-documentation/components/security/#backbee-securitycontext-and-the-contextinterface", 
            "text": "All the process of creating  Firewall ,  FirewallMap ,  AuthenticationManager ,  AccessDecisionMananger  and listeners is handled by the  BackBee\\Security\\SecurityContext  object.  However the way of dealing with security Listerners is simplyfied by using a  Context  object.\nA security  Context  extends the abstract class  BackBee\\Security\\Context\\BBAuthContext  and defines the  loadListeners  method.  LoadListeners  accepts one parameter which is the security config that can be setted in  repository/Config/security.yml .\nA context can be used to instanciate new listener or to register new authentication provider to the  SecuriryContext .  Bellow we show all the  security contexts provided by BackBee.   AnonymousContext  BBAuthContext  LogoutContext  RestfulContext  StatelessContext  UsernamePasswordContext   AnonymousContext  AnonymouseContext  is used to identify anonymous user.   authentication provider  :  BackBee\\Security\\Authentication\\Provider\\AnonymousAuthenticationProvider  Listener :  BackBee\\Security\\Listeners\\AnonymousAuthenticationListener  Token  :  BackBee\\Security\\Token\\AnonymousToken   BBAuthContext  BBAuthContext  is used to authentify a user by using the BackBee User table.   authentication provider  :  BackBee\\Security\\Authentication\\Provider\\BBAuthenticationProvider  Listener :  BackBee\\Security\\Listeners\\AnonymousAuthenticationListener  Token  :  BackBee\\Security\\Token\\BBUserToken   LogoutContext  LogoutContext  handles user logout by removing all setted tokens.   authentication provider  :  none  Token  :  none  Listener :  BackBee\\Security\\Listeners\\LogoutListener   RestfulContext  RestfulContext  is used to authentify rest user with a plublic key.   authentication provider :  BackBee\\Security\\Listeners\\PublicKeyAuthenticationProvider  Listener  :  BackBee\\Security\\Listeners\\PublicKeyAuthenticationListener  Token :  BackBee\\Security\\Token\\BBUserToken   StatelessContext  In stateless mode, authentication is asked for every requests.  StatelessContext  handles sessions\ncreation every time stateless mode is disabled.   authentication provider :  none  Listener :  BackBee\\Security\\Listeners\\ContextListener  Token :  none   UsernamePasswordContext  UsernamePasswordContext is used to authenticate user by using a login form.   authentication provider :  BackBee\\Security\\Listeners\\Provider\\UserAuthenticationProvider  Listener :  BackBee\\Security\\Listeners\\UsernamePasswordAuthenticationListener  Token :  BackBee\\Security\\Token\\UsernamePasswordToken", 
            "title": "BackBee SecurityContext and the ContextInterface"
        }, 
        {
            "location": "/developper-documentation/components/security/#configuring-security-with-securityyml", 
            "text": "Security configurations can be handled with a simple yml file. This file can be found in  repository/Config/security.yml .  firewalls:\n    bb_area:\n        pattern: ^/\n        requirements:\n            HTTP-X-Requested-With: XMLHttpRequest\n            HTTP-X-BB-METHOD: (JsonRpc|Upload)\n        provider: bb_user\n        bb_auth:\n            provider: bb_user\n            nonce_dir: security/nonces\n            lifetime: 1800\n            use_registry: true\n\nproviders:\n    bb_user:\n        entity:\n            class: BackBee\\Security\\User\n        secret: %secret_key%\n    public_key:\n        entity:\n            class: BackBee\\Security\\User\n\ncontexts:\n    BackBee\\Security\\Context: [StatelessContext, AnonymousContext, BBAuthContext, UsernamePasswordContext, LogoutContext, RestfulContext]\n\nencoders:\n    BackBee\\Security\\User:\n        class: Symfony\\Component\\Security\\Core\\Encoder\\MessageDigestPasswordEncoder\n        arguments:\n            algorithm: md5\n            encode_as_base64: false\n            iterations: 1\n\nacl:\n    connection: default", 
            "title": "Configuring Security with security.yml"
        }, 
        {
            "location": "/developper-documentation/components/translation/", 
            "text": "Components\n\n\nThe Translation component\n\n\nThis component is used in BackBee to translate text into differents languages. Note this component is an extension of \nSymfony Translation Component\n\n\nHow the translation work\n\n\nBackBee translation component override \nSymfony\\Component\\Translation\\Translator\n to lazy load every catalogs from:\n- BackBee\\Resources\\translations\n- PATH_TO_REPOSITORY\\Resources\\translations\n- PATH_TO_CONTEXT_REPOSITORY\\Resources\\translations.\n\n\nBackBee use \nXLIFF\n catalogs to translate statics contents into your templates.\n\n\nConfiguration\n\n\nBackBee become with own is catalog and it can be extended without configuration if you put your catalog into the folder \nrepository/translations\n, the file need some naming convention \nmessages.{locale}.xlf\n you need to adapt \n{locale}\n with one real locale like en, fr, etc.\n\n\nYou configure the default locale of the site in \nencoding.yml\n into \nrepository/Config\n folder. By default the value is \n~\n and is corresponding to \nen_US\n locale.\n\n\nThe Catalog\n\n\nFirst step will go to create our first catalog and need to follow the Oasis XLIFF specifications.\n\n\n?xml version=\n1.0\n?\n\n\nxliff version=\n1.2\n xmlns=\nurn:oasis:names:tc:xliff:document:1.2\n\n    \nfile source-language=\nen\n datatype=\nplaintext\n original=\nfile.ext\n\n        \nbody\n\n            \ntrans-unit id=\n1\n\n                \nsource\nhello.backbee\n/source\n\n                \ntarget\nHello BackBee !\n/target\n\n            \n/trans-unit\n\n        \n/body\n\n    \n/file\n\n\n/xliff\n\n\n\n\n\n\n\nIn this  catalog case we define that the string \nhello.backbee\n will be translate into \nHello BackBee !\n\n\n\n\nUse translation\n\n\nIn template you can access to the translator by the global \nbb\n and you can use is function \ntrans\n to translate your string.\n\n\n{{ bb.translator.trans('hello.backbee') }}\n\n\n\n\nThis will return \"Hello BackBee !\".\n\n\nFor using it out of the template you need to access to the Dependencies Invection Container and then you can use the \ntrans\n method.\n\n\n$translator = $this-\ngetApplication()-\ngetContainer()-\nget('translator');\n\n$translator-\ntrans('hello.backbee');\n\n\n\n\n\n\nthe getApplication method is depending in the context where you run your translation.\n\n\nIf you are in an event listener you need to  do \n$this-\ngetEventDispatcher()-\ngetApplication()-\n...\n\n\n\n\nLike before the result will be \"Hello BackBee !\".\n\n\nIf you want do some more advanced usage of the component translation you will found more information on \nSymfony Translation Component Usage Documentation", 
            "title": "Translation"
        }, 
        {
            "location": "/developper-documentation/components/translation/#components", 
            "text": "", 
            "title": "Components"
        }, 
        {
            "location": "/developper-documentation/components/translation/#the-translation-component", 
            "text": "This component is used in BackBee to translate text into differents languages. Note this component is an extension of  Symfony Translation Component  How the translation work  BackBee translation component override  Symfony\\Component\\Translation\\Translator  to lazy load every catalogs from:\n- BackBee\\Resources\\translations\n- PATH_TO_REPOSITORY\\Resources\\translations\n- PATH_TO_CONTEXT_REPOSITORY\\Resources\\translations.  BackBee use  XLIFF  catalogs to translate statics contents into your templates.  Configuration  BackBee become with own is catalog and it can be extended without configuration if you put your catalog into the folder  repository/translations , the file need some naming convention  messages.{locale}.xlf  you need to adapt  {locale}  with one real locale like en, fr, etc.  You configure the default locale of the site in  encoding.yml  into  repository/Config  folder. By default the value is  ~  and is corresponding to  en_US  locale.  The Catalog  First step will go to create our first catalog and need to follow the Oasis XLIFF specifications.  ?xml version= 1.0 ?  xliff version= 1.2  xmlns= urn:oasis:names:tc:xliff:document:1.2 \n     file source-language= en  datatype= plaintext  original= file.ext \n         body \n             trans-unit id= 1 \n                 source hello.backbee /source \n                 target Hello BackBee ! /target \n             /trans-unit \n         /body \n     /file  /xliff    In this  catalog case we define that the string  hello.backbee  will be translate into  Hello BackBee !   Use translation  In template you can access to the translator by the global  bb  and you can use is function  trans  to translate your string.  {{ bb.translator.trans('hello.backbee') }}  This will return \"Hello BackBee !\".  For using it out of the template you need to access to the Dependencies Invection Container and then you can use the  trans  method.  $translator = $this- getApplication()- getContainer()- get('translator');\n\n$translator- trans('hello.backbee');   the getApplication method is depending in the context where you run your translation.  If you are in an event listener you need to  do  $this- getEventDispatcher()- getApplication()- ...   Like before the result will be \"Hello BackBee !\".  If you want do some more advanced usage of the component translation you will found more information on  Symfony Translation Component Usage Documentation", 
            "title": "The Translation component"
        }
    ]
}